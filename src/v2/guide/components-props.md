---
title: Հատկություններ
type: ուղեցույց
order: 102
---

> Այս էջը ենթադրում է որ դուք արդեն կարդացել եք [Կոմպոնենտների Հիմունքները](components.html)։ Կարդացեք այն եթե դուք նոր եք ծանոթանում կոմպոնենտներին։

<div class="vueschool"><a href="https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs" target="_blank" rel="sponsored noopener" title="Սովորեք թե ինչպես են կոմպոնենտի հատկությունները աշխատում Vue School-ում">Սովորեք թե ինչպես են կոմպոնենտները աշխատում այս անվճար Vue School-ի դասում</a></div>

## Հատկությունների Casing-ը (camelCase-ը ընդեմ kebab-case-ի)

HTML ատրիբուտների անունները case-insensitive են, բրաուզերները կթարգմանեն ցանկացած մեծատաերով նիշեր որպես փոքրատառ։ Սա նշանակում է երբ որ դուք օգտագործում եք DOM-ում գտնվող ձևանմուշներ, camelCase-ով գրված հատկությունների անունները պետք է օգտագործեն իրենց kebab-case-ով փոփոխված համապատասխան անունները։

``` js
Vue.component('blog-post', {
  // camelCase-ը JavaScript-ում
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
```

``` html
<!-- kebab-case-ը HTML-ում -->
<blog-post post-title="բարև!"></blog-post>
```

Կրկին, եթե դուք օգտագործում եք տեքստային ձևանմուշներ, այս սահմանափակումը չի կիրառվի։

## Հատկությունների Տիպերը

Մինչ այժմ մենք միայն տեսել ենք հատկությունների ցանկեր որպես տեքստային արժեքների զանգված։

```js
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

Սովորականում, դուք կցանկանաք ամեն հատկությունը որ ունենա հատուկ տիպի արժեք։ Այս դեպքերում, դուք կարող եք ցուցակագրել հատակությունները որպես օբյեկտ, որտեղ հատկությունները՝ անունները և արժեքները պարունակում են հատկությունների անունները և տիպերը համապատասխանորեն։

```js
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // կամ որևէ այլ կոնստրուկտոր
}
```

Սա ոչ միայն փաստաթղթավորում է ձեր կոմպոնենտը, բայց նաև կնախազգուշացնի օգտագործողներին բրաուզերի JavaScript console-ում եթե նրանք փոխանցում են սխալ տիպը։ Դուք կարող եք իմանալ ավելին [տիպերի ստուգումները և այլ հատկությունների վավերացման մասին](#Prop-Validation) այս էջում ավելի ներքև։

## Ստատիկ Կամ Դինամիկ Հատկությունների Փոխանցումը

Մինչ դեռ, դուք տեսել եք որ հատկությունները փոխանցել են ստատիկ արժեքներ, ինչպես հետևյալն է՝

```html
<blog-post title="Իմ Ճամփորդությունը Vue-ի հետ"></blog-post>
```

Դուք նաև տեսել եք որ հատկությունները նշանակված են դինամիկորեն `v-bind`-ի հետ,  ինչպես հետևյալն է՝

```html
<!-- Դինամիկորեն փոփոխականի արժեքի նշանակումը -->
<blog-post v-bind:title="post.title"></blog-post>

<!-- Դինամիկորեն բարդ արտահայտության արժեքի նշանակումը -->
<blog-post
  v-bind:title="post.title + ' by ' + post.author.name"
></blog-post>
```

Վերևում գտնվող երկու օրինակներում, մենք փոխանցում ենք string արժեքներ, բայց _ցանկացած_ տիպի արժեք իրականում կարող է փոխանցվել։

### Թվի Փոխանցումը

```html
<!-- Չնայած որ `42`-ը ստատիկ է, մենք պետք է v-bind-ի միջոցով հասկացնել Vue-ին որ դա -->
<!-- JavaScript-ի արտահայտություն է այլ ոչ թե string։ -->
<blog-post v-bind:likes="42"></blog-post>

<!-- Դինամիկորեն փոփոխականի արժեքի նշանակումը -->
<blog-post v-bind:likes="post.likes"></blog-post>
```

### Boolean-ի Փոխանցումը

```html
<!-- Ներառելով հատկություն առանց արժեքի կհաշվարկվի որպես `true` -->
<blog-post is-published></blog-post>

<!-- Չնայած որ `false`-ը ստատիկ է, մենք պետք է v-bind-ի միջոցով հասկացնել Vue-ին որ դա -->
<!-- JavaScript-ի արտահայտություն է այլ ոչ թե string։ -->
<blog-post v-bind:is-published="false"></blog-post>

<!-- Դինամիկորեն փոփոխականի արժեքի նշանակումը։ -->
<blog-post v-bind:is-published="post.isPublished"></blog-post>
```

### Զանգվածի Փոխանցումը

```html
<!-- Չնայած որ զանգվածը ստատիկ է, մենք պետք է v-bind-ի միջոցով հասկացնել Vue-ին որ դա -->
<!-- JavaScript-ի արտահայտություն է այլ ոչ թե string։ -->
<blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>

<!-- Դինամիկորեն փոփոխականի արժեքի նշանակումը։ -->
<blog-post v-bind:comment-ids="post.commentIds"></blog-post>
```

### Օբյեկտի Փոխանցումը

```html
<!-- Չնայած որ օբյեկտը ստատիկ է, մենք պետք է v-bind-ի միջոցով հասկացնել Vue-ին որ դա -->
<!-- JavaScript-ի արտահայտություն է այլ ոչ թե string։ -->
<blog-post
  v-bind:author="{
    name: 'Veronica',
    company: 'Veridian Dynamics'
  }"
></blog-post>

<!-- Դինամիկորեն փոփոխականի արժեքի նշանակումը։ -->
<blog-post v-bind:author="post.author"></blog-post>
```

### Օբյեկտի Հատկությունների Փոխանցումը

Եթե դուք ցանկանում եք փոխանցել բոլոր հատկությունների օբյեկտը որպես props, դուք կարող եք օգտագործել `v-bind`-ը առանց արգումենտի (`v-bind`-ի փոխարեն `v-bind:prop-name`)։ Օրինակ՝ տրված `post` օբյեկտը։

``` js
post: {
  id: 1,
  title: 'Իմ Ճամփորդությունը Vue-ի հետ'
}
```

Այս ձևանմուշում։

``` html
<blog-post v-bind="post"></blog-post>
```

Հավասար կլինի սրան։

``` html
<blog-post
  v-bind:id="post.id"
  v-bind:title="post.title"
></blog-post>
```

## Մեկ Ճանապարհով Տվյալների Հոսքը

Բոլոր հատկությունները կազմում են **մեկ ճանապարհ ներքև կապում** ժառանգողի հատկության և ծնողինի միջև․ երբ ծնողի հատկությունը փոփոխվում է, այն կփոխանցվի ժառանգողին, բայց ոչ հակառակ ուղղությամբ։ Սա օգնում է մեզ խուսափել ժառանգող կոմպոնենտների միամիտորեն ծնողի վիճակի (state-ի) մուտացիայի ենթարկելուց, որը դարձնում է ձեր ծրագրի տվյալների հոսքը ավելի բարդ հասկանալու համար։

Ի հավելումն, ամեն անգամ երբ ծնող կոմպոնենտը թարմացված է, բոլոր հատկությունները ժառանգող կոմպոնենտում նույնպես կթարմացվեն վերջին արժեքներով։ Սա նշանակում է որ դուք **չ՛պետք** է փոխձեք մուտացիայի ենթարկել հատկությունը ժառանգող կոմպոնենտում։ Եթե դուք անեք դա, Vue-ն ձեզ կզգուշացնի console-ի մեջ։

Սովորականում կան երկու դեպքեր երբ գայթակղիչ է հատկության մուտացիայի ենթարկումը։

1. **Հատկությունը օգտագործվում է որպեսզի փոխանցվի սկզբնական արժեքում; ժառանգող կոմպոնենտը ցանկություն ունի օգտագործելու որպես լոկալ տվյալների հատկություն հետագայում։** Այս դեպքում, լավագույնը կլինի որպեսզի հայտարարել լոկալ տվյալների հատկություն որը օգտագործում է prop-ը որպես սկզբնական արժեք։

  ``` js
  props: ['initialCounter'],
  data: function () {
    return {
      counter: this.initialCounter
    }
  }
  ```

2. **Prop-ը փոխանցված է որպես չմշակված արժեք որը պետք է փոփոխվի։** Այս դեպքում, լավագույնը կլինի որպեսզի հայտարարել հաշվարկված հատկություն օգտագործելով prop-ի արժեքը։

  ``` js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

<p class="tip">Նշում որ օբյեկտները և զանգվածները JavaScript-ում փոխանցված են reference-ի միջոցով, այնպես որ եթե prop-ը զանգված է կամ օբյեկտ, մուտացիայի ենթարկելու օբյեկտը կամ զանգվածը ժառանգող կոմպոնենտում **կազդի** ծնողի state-ի վրա։</p>

## Prop-ի Վալիդացիա

Կոմպոնենտները կարող են նշել պահանջներ իրենց prop-ների համար, ինչպիսին են այն տիպերը որոնք դուք արդեն տեսել էք։ Եթե որևէ պահանջ չի բավարարվում, Vue-ն ձեզ կզգուշացնի բրաուզերի JavaScript console-ի մեջ։ Սա հատկապես օգտակար է երբ ծրագրավորում եք կոմպոնենտներ որոնք նախատեսված են որպեսզի օգտագործեն ուրիշ կոմպոնենտների կողմից։

Որպեսզի նշել prop-ի վալիդացումը, մենք կարող են տրամադրել օբյեկտ վավերացման պահանջներով `props`-ի արժեքին, ի փոխարեն string-ների զանգվածի։ Օրինակ՝

``` js
Vue.component('my-component', {
  props: {
    // Սովորական տիպի ստուգում (`null` և `undefined` արժեքները կանցնեն ցանկացած տիպի կողմնորոշման վալիդացիա)
    propA: Number,
    // Մի քանի հնարավոր տիպեր
    propB: [String, Number],
    // Պահանջվող որպես string
    propC: {
      type: String,
      required: true
    },
    // Թիվ հիմնական արժեքով
    propD: {
      type: Number,
      default: 100
    },
    // Օբյեկտ հիմնական արժեքով
    propE: {
      type: Object,
      // Օբյեկտի կամ զանգվածի հիմնական արժեքները պետք է վերադարձվեն
      // factory ֆունկցիայից
      default: function () {
        return { message: 'բարև' }
      }
    },
    // Custom validator ֆունկցիա
    propF: {
      validator: function (value) {
        // Արժեքը պետք է համապատասխանի հետևյալ string-ներից մեկին
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```

Երբ prop-ի վալիդացիան ձախողվում է, Vue-ն կարտադրի console-ի նախազգուշացում (եթե օգտագործում եք development build-ը)

<p class="tip">Նշում որ prop-ները վալիդացվում են **նախքան** կոմպոնենտնի instance-ի ստեղծումը, այնպես որ instance-ի հատկությունները (օրինակ՝ `data`, `computed`, և այլն) հասանելի չեն լինի `default` կամ `validator` ֆունկցիաների ներսում։</p>

### Տիպի Ստուգում

`type`-ը կարող է լինել հետևյալ կոնստրուկտորներից մեկը։

- String
- Number
- Boolean
- Array
- Object
- Date
- Function
- Symbol

Ի հավելումն, `type`-ը կարող է նաև լինել հատուկ (custom) կոնստրուկտոր ֆունկցիա և պնդումը կկատարվի `instanceof`-ի հետ ստուգմամբ։ Օրինակ՝ ենթադրելով որ հետևյալ կոնստրուկտորի ֆունկցիան գոյություն ունի:

```js
function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}
```

Դուք կարող եք օգտագործել:

```js
Vue.component('blog-post', {
  props: {
    author: Person
  }
})
```

Որպեսզի ստուգենք որ `author` prop-ի արժեքը ստեղծվել է `new Person`-ի միջոցով։

## Ոչ Prop Ատրիբուտներ

Ոչ prop ատրիբուտը դա ատրիբուտ է որը փոխանցված է կոմպոնենտին, բայց չունի համապատասխան prop-ը հայտարարված։

Երբ բացահայտ հայտարարված prop-ները նախատեսված են փոխանցելու ինֆորմացիա ժառանգող կոմպոնենտին, կոմպոնենտների գրադարանների հեղինակները միշտ չեն կարող տեսնել թե ինչպես իրենց կոմպոնենտները կարող են օգտագործել։ Այս պատճառով կոմպոնենտները կարող են ընդունել կամայական ատրիբուտներ, որոնք ավելացված են կոմպոնենտի արմատային էլեմենտում։

Օրինակի համար, պատկերացրեք մենք օգտագործխում ենք 3-րդ կողմի `bootstrap-date-input` կոմպոնենտ Bootstrap plugin-ի հետ հանդերձ որը պահանջում է `data-date-picker` ատրիբուտը `input`-ի վրա։ Մենք կարող են ավելացնել այս ատրիբուտը մեր կոմպոնենտի instance-ին։

``` html
<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
```

ԵՎ `data-date-picker="activated"` ատրիբուտը ավտոմատ կերպով կավելացվի `bootstrap-date-input`-ի արմատային էլեմենտին։

### Փոխել/Ձուլելը Գույություն Ունեցող Ատրիբուտների Հետ

Պատկերացրեք սա `bootstrap-date-input`-ի ձևանմուշն է։

``` html
<input type="date" class="form-control">
```

Որպեսզի նշել ոճի թեմա մեր date picker plugin-ի համար, մենք պետք է ավելացնենք հատուկ class, այսպես՝

``` html
<bootstrap-date-input
  data-date-picker="activated"
  class="date-picker-theme-dark"
></bootstrap-date-input>
```

Այս դեպքում, երկու տարբեր արժեքներ են հայտարարված `class`-ի համար։

- `form-control`, որը դրված է կոմպոնենտի կողմից իր ձևանմուշում
- `date-picker-theme-dark`, որը փոխանցվել է կոմպոնենտին իր ծնողի կողմից

Շատ ատրիբուտներում, արժեքը որը տրամադրված է կոմպոնենտին կփոխի այն արժեքը որը դրվել է կոմպոնենտի կողմից։ Օրինակի համար, փոխանցելով `type="text"`-ը կփոխի `type="date"` և հնարավոր է որ կոտրի այն՜ Բարեբախտաբար, `class` և `style` ատրիբուտները մի փոքր խելացի են, այնպես որ երկուսի արժեքները կձուլվեն և վերջնական արժեքը կլինի `form-control date-picker-theme-dark`։

### Ատրիբուտների Ժառանգման Անջատումը

Եթե դուք **չ՛եք** ցանկանում որպեսզի կոմպոնենտին արմատային էլեմենտը ժառանգի ատրիբուտները, դուք կարող եք տեղադրել `inheritAttrs: false` այն կոմպոնենտի ընտրանքներում։ Օրինակ՝

```js
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```

Սա կարող է հատկապես օգտակար լինել `$attrs`-ի հետ համատեղ, որը պարունակում է ատրիբուտների անունները և արժեքները որոնք փոխանցվում են կոմպոնենտի, ինչպիսին են․

```js
{
  required: true,
  placeholder: 'Enter your username'
}
```

`inheritAttrs: false` և `$attrs`-ի հետ, դուք կարող եք ձեռքով որոշել թե որ էլեմենտին եք ուզում ուղարկել ատրիբուտները, որը հատկապես ցանկալի է [հիմնական կոմպոնենտներում](../style-guide/#Base-component-names-strongly-recommended):

```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```

<p class="tip">Նշում որ `inheritAttrs: false` ընտրանքը **չի** ազդի `style` և `class` կապերի վրա։</p>

Այս pattern-ը թույլ է տալիս ձեզ օգտագործելու հիմնական կոմպոնենտները որպես չոր HTML էլեմենտներ, առանց մտածելու, թե որ էլեմենտն է իրականում իր արմատում։

```html
<base-input
  label="Username:"
  v-model="username"
  required
  placeholder="Enter your username"
></base-input>
```
