---
title: Համեմատությունը ուրիշ Framework-երի հետ
type: ուղեցույց
order: 801
---

Սա հաստատ ուղեցույց գրելու ամենադժվար էջն է, բայց մենք կարծում ենք, որ դա կարևոր է: Հնարավոր է, որ դուք խնդիրներ ունեցել եք, որոնք փորձել եք լուծել, և դրանք լուծելու համար մեկ այլ գրադարան եք օգտագործել: Դուք այստեղ եք, քանի որ ուզում եք իմանալ, արդյոք Vue-ն կարող է ավելի լավ լուծել ձեր խնդիրները: Դա այն է, ինչ մենք հույս ունենք պատասխանել ձեզ համար:


Մենք նաև շատ ենք ջանում խուսափել կողմնակալությունից։ Որպես հիմնական թիմ, մենք ակնհայտորեն շատ ենք հավանում Vue-ն: Կան որոշ խնդիրներ, որոնք մենք կարծում ենք, որ այն լուծում է ավելի լավ, քան ցանկացած այլ տեղ: Եթե չհավատայինք, չէինք աշխատի դրա վրա: Մենք, այնուամենայնիվ, ուզում ենք լինել արդար և ճշգրիտ: Եթե այլ գրադարաններ առաջարկում են զգալի առավելություններ, ինչպիսիք են React-ի այլընտրանքային renderer-ների հսկայական էկոհամակարգը կամ Knockout-ի բրաուզերի աջակցությունը IE6-ին, մենք փորձում ենք թվարկել նաև դրանք:

Մենք կցանկանայինք, որ **ձեր** օգնությամբ այս փաստաթուղթը թարմացվի, քանի որ JavaScript-ի աշխարհը արագ է ընթանում: Եթե նկատում եք անճշտություն կամ որևէ բան, որը այնքան էլ ճիշտ չի թվում, խնդրում ենք տեղեկացնել մեզ [բացելով թողարկում](https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide)։

## React

React-ը և Vue-ն ունեն շատ նմանություններ։ Երկուսնել․

- օգտագործում են վիրտուալ DOM
- ապահովում են ռեակտիվ և կապակցվող տեսքի կոմպոնենտներ
- ուշադրության կենտրոնում են պահում հիմնական գրադարանը` այնպիսի մտահոգություններով, ինչպիսիք են routing-ը և գլոբալ վիճակի կառավարումը, որոնք վարվում են ուղեկից գրադարանների կողմից։

Լինելով այդքան շատ նման ծավալով, մենք ավելի շատ ժամանակ ենք դրել այս համեմատությունը լավացնելու համար, քան ցանկացած այլ: Մենք ուզում ենք ապահովել ոչ միայն տեխնիկական ճշգրտություն, այլև հավասարակշռությունը: Մենք նշում ենք, թե որտեղ է React-ը գերազանցում Vue-ին, օրինակ `նրա էկոհամակարգի հարստության և իր renderer-ների առատության մեջ:

Այսպես ասած, անխուսափելի է, որ համեմատությունը Vue-ին կողմնակալ լիներ որոշ React օգտագործողների համար, քանի որ ուսումնասիրվող առարկաներից շատերը որոշ չափով սուբյեկտիվ են: Մենք գիտակցում ենք տարբեր տեխնիկական ճաշակի առկայությունը, և այս համեմատությունը հիմնականում նպատակ ունի ուրվագծելու այն պատճառները, թե ինչու Vue-ն կարող է պոտենցիալ ավելի լավը լինել, եթե ձեր նախասիրությունները հանդիպում են մերինի հետ:

Ստորև բերված բաժիններից մի քանիսը կարող են փոքր-ինչ հին լինել React 16+-ում վերջին թարմացումների պատճառով, և մենք պլանավորում ենք աշխատել React համայնքի հետ `մոտ ապագայում վերանայելու այս հատվածը:

### Runtime Գործունակությունը

Թե React-ը և Vue-ն բացառիկ և նմանապես արագ են, ուստի արագությունը դժվար թե որոշիչ գործոն լինի նրանց միջև ընտրելու համար: կամ առանձնահատկությունների չափումներ, այնուամենայնիվ, ստուգեք այս [3-րդ կողմի benchmark-ը](https://stefankrause.net/js-frameworks-benchmark8/table.html), որը կենտրոնանում է շատ պարզ կոմպոնենտների ծառերի հումքի render/update-ի վրա։

#### Օպտիմիզացման Ջանքեր

React-ում, երբ կոմպոնենտի վիճակը (state-ը) փոխվում է, այն միացնում է վերամատուցումը ամբողջ կոմպոնենտների ենթածառի համար, սկսելով այդ կոմպոնենտից որպես արմատ։ Որպեսզի զերծ մնանք ավելորդ ժառանգող կոմպոնենտների վերամատուցողներից, դուք պետք է կամ օգտագործեք `PureComponent` կամ իրականացնել `shouldComponentUpdate`-ը երբ որ կարող եք։ Դուք նաև պետք է օգտագործել չ՛մուտացիայի ենթարկվող տվյալների ստրուկտուրան որպեսզի ձեր ծրագրի վիճակի փոփոխությունները լինեն ավելի օպտիմիզացիային մոտիկ։ Այնուամենայնիվ, որոշ դեպքերում հնարավոր է, որ չկարողանաք վստահ լինել այդպիսի օպտիմիզացիաների վրա քանի որ `PureComponent/shouldComponentUpdate`-ը ենթադրում է ամբողջ ենթածառի render-ի ելքագրումը կախված է կոմպոնենտի հատկություններից։ Եթե դա այդպես չէ, ապա այդպիսի օպտիմիզացիաները կարող են հանգեցնել անհամապատասխան DOM վիճակի:

Vue-ի մեջ, կոմպոնենտի dependency-ները ավտոմատ կերպով գտնվում են նրա render-ի համար, սրանից դատելով համակարգը ճշգրիտ գիտի, թե որ կոմպոնենտները պետք է re-render լինեն երբ վիճակը (state-ը) փոխվում է։ Ամեն կոմպոնենտը կարելի է համարել որ ունի `shouldComponentUpdate`-ը տեղադրված ձեր համար, առանց նրա միջի կոմպոնենտների նախազգուշացումների։

Ընդհանուր առմամբ, դա հեռացնում է ծրագրավորողի կողմից կատարվող օպտիմիզացման մի ամբողջ դասի անհրաժեշտությունը և թույլ է տալիս նրանց ավելի շատ կենտրոնանալ ծրագրի կառուցելու վրա։

### HTML և CSS

React-ում, ամեն ինչ պարզածես JavaScript է։ Ոչ միայն HTML-ի կառուցվածքն է արտահայտված JSX-ով, վերջին միտումները նույնպես հակված են CSS-ը տեղադրումը JavaScript-ի ներսում։ Այս մոտեցումը ունի նրա առավելությունները, բայց մյուս դեպքում կան բազմազան հակասումները որոնք ոչ բոլոր ծրագրավորողների համար են։

Vue-ն ընդգրկում է դասական վեբ տեխնոլոգիաները և կառուցվում է դրանցից վեր: Ձեզ ցույց տալու համար, թե դա ինչ է նշանակում, մենք կանդրադառնանք մի քանի օրինակների:

#### JSX-ը ընդեմ Ձևանմուշների

React-ում, բոլոր կոմպոնենտները արտահայտում են իրենց UI-ները render ֆունկցիայի մեջ օգտագործելով JSX, որը աշխատում է JavaScript-ի ներքո և ունի դեկլարատիվ XML տիպի գրելաձև։

Render ֆունկցիաները JSX-ում ունեն մի քանի առավելություն։

- Դուք կարող եք օգտագործել ամբողջական ծրագրավորման լեզու (JavaScript-ը) որպեսզի կառուցեք տեսքը: Սա ներառում է ժամանակավոր փոփոխականներ, հոսքի վերահսկում և ուղղակիորեն հղում անելով JavaScript-ի արժեքներին:
- JSX-ի համար գործիքները (օր.՝ linting, տիպի ստուգում, խմբագրիչի ինքնալրացում) որոշ առումներով ավելի առաջադեմ են, քան այն, ինչ ներկայումս առկա է Vue-ի ձևանմուշների համար:

Vue-ում, մենք նաև ունենք [render ֆունկցիաներ](render-function.html) և նույնիսկ [JSX](render-function.html#JSX), որովհետև մեկմեկ ձեզ պետք կգա այդ ուժը։ Ամեն դեպքում, որպես հիմնական փորձ մենք առաջարկում ենք ձևանմուշներ որպես պարզ այընտրանք։ Ամեն ճիշտ HTML նաև ճիշտ Vue-ի ձևանմուշ է, որը ունի մի քանի առավելություն։

- Շատ ծրագրավորողների համար ովքեր աշխատում են HTML-ով, ձևանմուշները կարող են լինել ավելի հեշտ կարդալու և գրելու համար։ Այս նախընտրությունը իրենով կարող է լինել որոշ չափով սուբյեկտիվ, բայց եթե այն ծրագրավորողին տալիս է հնարավորություն որպեսզի լիներ ավելի արդյունավետ որեմն օգուտը օբյեկտիվ է։

- HTML-ով հիմք ունեցող ձևանմուշները ավելի հեշտ է աստիճանաբար տեղադրել գոյություն ունեցող ծրագրերի մեջ որպեսզի այն ամբողջովին ստանա Vue-ի ռեակտիվության առավելությունները։

- Այն նաև ավելի հեշտ է դիզայներներին և քիչ փորձ ունեցող ծրագրավորողներին որպեսզի վերլուծեն և նպաստեն կոդավորմանը։

- Դուք կարող եք նաև օգտագործել pre-processor-ներ ինչպիսին է Pug (նախկինում Jade-ը) որպեսզի հեղինակել ձեր Vue ձևանմուշները։

Որոշները կարող են վիճել որ դուք պետք է սովորեք հավելյալ DSL (Domain-Specific Language) որպեսզի գրեք ձևանմուշներ - մենք հավատում ենք որ այս տարբերությունը մակերեսային է լավագույն դեպքում։ Առաջինը, JSX-ը չի նշում, որ օգտագործողը կարիք չունի սովորելու - այն հավելյալ գրելաձև է որը աշխատում է չոր JavaScript-ի վրայից, և այդ պատճառով այն կարող է լինել հեշտ այն օգտագործողի համար ով ծանոթ է JavaScript-ի հետ, բայց ասելով, որ այն ըստ էության ազատ է, ապակողմնորոշիչ է։ Նմանապես, ձևանմուշը պարզապես հավելյալ գրելաձև է որը աշխատում է չոր HTML-ի վրայից և դատելով դրանից ունի շատ ցածր սովորելու պահանջ նրանց համար ովքեր ծանոթ են HTML-ի հետ։ DSL-ի հետ մենք կարող ենք նաև օգնել օգտագործողին որպեսզի ավելիին հասնի ավելի քիչ կոդավորմամբ (օրինակ՝ `v-on` փոփոխիչները)։ Նույն հանձնարարությունը կարող է ունենալ ավելի շատ կոդ երբ օգտագործում ենք չոր JSX կամ render ֆունկցիաներ։

Ավելի բարձր աստիճանում, մենք կարող ենք բաժանել կոմպոնենտները երկու կատեգորիաների։ Ցուցադրական և տրամաբանական։ Մենք խորհուրդ ենք տալիս օգտագործելու ձևանմուշներ ցուցադրական կոմպոնենտների և render ֆունկցիաները / JSX տրամաբանականների համար։ Տոկոսը այս կոմպոնենտների կախված է ծրագրի տիպի հետ որը դուք կառուցում եք, բայց հիմնականում մենք համարում ենք որ ցուցադրականները ավելի տարածված են։

#### Component-ի ներքին CSS

Եթե դուք չեք տարածում կոմպոնենտները բազմաթիվ ֆայլերի (օրինակ՝ [CSS Մոդուլների հետ](https://github.com/gajus/react-css-modules)), scoping-ը CSS-ի React-ում շատ հաճախ արվում է CSS-JS-ի մեջ լուծումներով (օրինակ՝ [styled-components](https://github.com/styled-components/styled-components) և [emotion](https://github.com/emotion-js/emotion))։ Սա ներկայացնում է նոր կոմպոնենտ-կողմնորոշված ձևավորում որը տարբերվում է սովորական CSS-ի հեղինակային գործընթացից։ Բացի այդ, չնայած կա հնարավորություն կառուցման ժամանակ CSS-ը դուրս հանելու դեպի մեկ stylesheet, այն դեռ տարածված է որ runtime-ը պետք է ընդգրկված լինի bundle-ում որպեսզի ոճերը ճիշտ աշխատեն։ Մինչ դուք կստանաք հնարավորություն օգտագործելու դինամիզմը JavaScript-ի երբ կառուցում եք ձեր ոճերը, հակասումները հաճախ լինում են ավելացված bundle-ի չափսը և runtime-ի արժեքը։

Եթե դուք CSS-ը JS-ի մեջ երկրպագուն եք, շատ ճանաչված CSS-ը JS-ի մեջ գրադարաններ աշխատում են Vue-ի հետ (օրինակ՝ [styled-components-vue](https://github.com/styled-components/vue-styled-components) և [vue-emotion](https://github.com/egoist/vue-emotion))։ Հիմնական տարբերությունը React-ի և Vue-ի միջև այստեղ դա հիմնական մեթոդը ոճաորելու Vue-ի մեջ կատարվում է ծանոթ `style` tag-երով [մեկ-ֆայլ կոմպոնենտների](single-file-components.html) մեջ։

[Մեկ-ֆայլ կոմպոնենտներ](single-file-components.html) տալիս են ձեզ CSS-ի բոլոր հնարավորությունները որպես մնացած մասը ձեր կոմպոնենտի կոդի։

``` html
<style scoped>
  @media (min-width: 250px) {
    .list-container:hover {
      background: orange;
    }
  }
</style>
```

Երկրորդական `scoped` ատրիբուտը ավտոմատ կերպով scope է անում այս CSS-ը ձեր կոմպոնենտին ավելացնելով եզակի ատրիբուտ (ինչպիսին է `data-v-21e5b78`-ը) էլեմենտների և compile է անում `.list-container:hover`-ը նման մի բանի `.list-container[data-v-21e5b78]:hover`։

ԵՎ վերջինը, ոճավորումը Vue-ի մեկ-ֆայլ կոմպոնենտներում շատ ճկուն է։ [Vue-loader-ի](https://github.com/vuejs/vue-loader) միջոցով դուք կարող եք օգտագործել ցանկացած preprocessor, post-processor, և նաև խորը ինտեգրացիա [CSS Մոդուլների](https://vue-loader.vuejs.org/en/features/css-modules.html) հետ -- այս ամենը `<style>` էլեմենտում։

### Զարգացումը

#### Զարգացումը

Մեծ ծրագրերի համար, Vue-ն և React-ը առաջարկում են կայուն routing-ի լուծումներ։ React-ի համայնքը նաև եղել է շատ նորարարական վիճակի (state-ի) կառավարման լուծումներով (օրինակ՝ Flux/Redux): Այս վիճակի կառավարման pattern-ները և [նույնիսկ Redux-ը իրենով](https://yarnpkg.com/en/packages?q=redux%20vue&p=1) կարող է հեշտ տեղադրվել Vue-ի ծրագրերում։ Ավելին, Vue-ն նույնիսկ գնացել է մեկ քայլ առաջ [Vuex-ով](https://github.com/vuejs/vuex), որը Elm-ով ոգեշնչված state-ի կառավարման լուծում է որը տեղադրվում է Vue—ի մեջ և մենք կարծում ենք առաջարկում է ավելի բարձրակարգ փորձ զարգացման համար։

Մեկ այլ կարևոր տարբերություն է այդ առաջարկություններում որ Vue-ի օգնական գրադարանները state-ի կառավարման և routing-ի (ի թիվս [այլ մտահոգությունները](https://github.com/vuejs)) բոլորը պաշտոնապես համապատասխանում են Vue-ին և պահպանված են թարմացված վիճակում հիմնական գրադարանի հետ։ React-ը փոխարենը ընտրում է թողնել այս մտահոգությունները համայնքնին, ստեղծելով ավելի բաժանված էկոհամակարգ։ Լինելով ավելի ճանաչված, React-ի էկոհամակարգը զգալիորեն ավելի հարուստ է Vue—ինից։

Վերջինը, Vue-ն առաջարկում է [CLI նախագծի գեներատոր](https://github.com/vuejs/vue-cli) որը հեշտացնում է նոր նախագծի սկսումը որը աջակցված է ինտերակտիվ նախագծի scaffolding wizard-ի հետ։ Դուք կարող եք նաև օգտագործել այն [ակնթարթային prototyping](https://cli.vuejs.org/guide/prototyping.html#instant-prototyping) անելու համար կոմպոնենտը։ React-ը նաև լուրջ քայլեր է ձեռնարկում այս ոլորտում [create-react-app](https://github.com/facebookincubator/create-react-app), բայց այն դեռ ունի մի քանի սահմանափակումներ։

- Այն թույլ չի տալիս որևէ կոնֆիգուրացիա նախագծի գեներացման ժամանակ, երբ Vue CLI աշխատում է զարգացվող runtime dependency-ի վրայից որը հնարավոր է հարստացնել [plugin-ների](https://cli.vuejs.org/guide/plugins-and-presets.html#plugins) շնորհիվ։
- Այն միայն առաջարկում է մեկ ձևանմուշ որը ենթադրում է որ դուք կառուցում եք մեկ-էջ ծրագիր, երբ որ Vue-ն առաջակում է տարբեր ընտրանքներ տարբեր նպատակների և համակարգերի կառուցման համար։
- Այն չի կարող գեներացնել նախագծեր օգտագործողի կողմից կառուցված [preset-ներով](https://cli.vuejs.org/guide/plugins-and-presets.html#presets), որը կարող է հատկապես օգտակար լինել ձեռնարկությունների միջավայրերի համար որոնք ունեն նախապես հաստատված կոնվենցիաներ։

Կարևոր է նշել, որ այս սահմանափակումներից շատերը create-react-app թիմի կողմից ընդունված նախագծային որոշումներ են, և դրանք ունեն իրենց առավելությունները։ Օրինակ՝ եթե ձեր նախագիծի պահանջները շատ պարզ են և դուք երբեք չ՛պետք է "հանեք" որպեսզի ձեր կառուցման գործընթացը հարմարեցնեք ձեզ համար, դուք հնարավորություն կունենաք այն թարմացնելու որպես dependency։ Դուք կարող եք կարդալ ավելին [տարբեր փիլիսոփայություների մասին այստեղ](https://github.com/facebookincubator/create-react-app#philosophy)։

####  Զարգացումը իջնելով

React—ը հայտնի է իր ուսուցումը դժվար լինելով։ Նախքան դուք կարող եք իրոք սկսել աշխատելը, դու պետք է իմանաք JSX-ի և հավանաբար ES2015+ մասին, որովհետև շատ օրինակներ օգտագործում են React-ի class գրելաձևը։ Դուք նաև պետք է սովորեք կառուցման համակարգերի մասին, որովհետև ամեն դեպքում դուք կարող եք օգտագործել Babel Standalone-ը որպեսզի live-compile անեք ձեր կոդը բրաուզերում, դա բացարձակապես պիտանի չէ արտադրության համար։

Երբ Vue-ն զարգացվում React-ի պես լավ, այն նաև զարգացվում է իջնելով բավականին լավ ինչպես jQuery-ն։ Դա ճիշտ է `սկսելու համար դուք պետք է միայն մեկ script tag գցեք էջում:

``` html
<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
```

Այնուհետև դուք կարող եք սկսել գրել ձեր Vue կոդը և նույնիսկ ստեղծել minified տարբերակը արտադրության համար առանց մեղավոր զգալու կամ performance-ի հետ կապված խնդիրների մասին անհանգստանալու։

Քանի որ կարիք չկա իմանալ JSX-ի, ES2015-ի, կամ կառուցման համակարգերի մասին որպեսզի աշխատել Vue-ի հետ, այն նաև ուղղակիորեն խլում է ծրագրավորողից մեկ օրից ավելի քիչ որպեսզի նա կարդա [այս ուղեցույցը](./) և սովորի բավականին որ կառուցի թեթև ծրագրեր։

### Native Rendering

React Native-ը թույլ է տալիս ձեզ գրել native-render եղած ծրագեր iOS-ի և Android-ի համար օգտագրոծելով նույն React կոմպոնենտի մոդելը։ Սա շատ լավ է ծրագրավորողի համար, դուք կարող եք կիրառեք ձեր framework-ի իմացությունները բազմաթիվ հարթակներում։ Այս դեպքում Vue-ն ունի պաշտոնական համագործակցություն [Weex-ի](https://weex.apache.org/) հետ, cross-platform UI framework որը ստեղծել է Alibaba Group-ը և այն ինկուբացնում է Apache Software Foundation-ը (ASF): Weex-ը թույլ է տալիս ձեզ օգտագործել նույն Vue կոմպոնենտի գրելաձևը հեղինակելու կոմպոնենտները որոնք չեն կարող միայն render լիել բրաուզերում, բայց նաև iOS-ում և Android-ում!

Այս պահին, Weex-ը դեռ ակտիվ զարգացման մեջ է և այն դեռ հասուն և մարտական փորձ չունի ինչես React Native-ը, բայց իր զարգացումը տարվում է ըստ արտադրման պահանջների ամենամեծ էլեկտրոնային առևտրի բիզնեսն աշխարհում, և Vue թիմը նույնպես ակտիվորեն համագործակցում է Weex թիմի հետ որպեսզի համոզվի Vue ծրագրավորողների հարթ փորձի մեջ։

Մյուս տարբերակը [NativeScript-Vue-ն](https://nativescript-vue.org/) է, [NativeScript-ի](https://www.nativescript.org/) plugin իրական native ծրագրեր կառուցելու համար օգտագործելով Vue.js-ը։

### MobX-ի հետ

MobX-ը դարձել է հայտնի React-ի համայնքում և այն օգտագործում է մոտ նույնական ռեակտիվության համակարգը Vue-ի։ Սահմանափակ չափով, React + MobX գործընթացը կարող է թվալ որպես ավելի բառալի Vue-ից, դատելով եթե դուք օգտագործում է այդ համադրությունը և վայելում եք դա, սկսելով Vue-ով աշխատելը կլինի հաջորդ տրամաբանական քայլը։

### Preact և ուրիշ React-ին նման գրադարաններ

React-ին նման գրադարանները պարզապես փորձում են կիսվել իրենց API-ով և էկոհամակարգով React-ի հետ որպես իրագործելի։ Այդ պատճառով, վերոնշյալ համեմատությունների ճնշող մեծամասնությունը նույնպես կկիրառվի դրանց վրա։ Հիմնական տարբերությունը կլինի նվազեցված էկոհամակարգ, երբեմն չափից շատ, համեմատաբար React-ի հետ։ Երբ այս գրադարանները չեն կարող լինեն 100% համապատասխան ամենինչին React-ի էկոհամակարգում, որոշ գործիքներ և աջակցող գրադարաններ չեն կարող կիրառվել։ Կամ, նույնիսկ եթե նրանք թվան որ աշխատում են, նրանք կարող են կոտրվել ցանկացած ժամանակ բացառապես եթե դուք օգտագործեք հատուկ React-ին նման գրադարան որը ամբողջովին համապատասխանում է React-ի հետ։

## AngularJS (Angular 1)

Vue-ի որոշ գրելաձևը կարող է թվալ շատ նման AngularJS-ին (օրինակ՝ `v-if` ընդեմ `ng-if`): Որովհետև շատ բաներ AngularJS-ը ունի ճիշտ և նրանք ոգեշնչեցին Vue-ին իր վաղ զարգացման ժամանակ։
Կան նաև շատ ցավեր որոնք գալիս են AngularJS-ի հետ, սակայն, այդ տեղերում Vue-ն առաջարկում է բավականին լավ բարելավումներ։

### Բարդությունը

Vue-ն ավելի պարզ է համեմատաբար AngularJS-ի հետ, երկուսնել աշխատում են API-ի և դիզայնի հիմնական պայմաններում։ Սովորելը բավական է կառուցելու պարզ ծրագրեր և սովորականորեն տևում է մեկ օրվանից քիչ, որը ճիշտ չէ AngularJS-ի դեպքում։

### Ճկունությունը և Մոդուլարություն

AngularJS-ը ունի ուժեղ կարիքներ թե ինչպես ձեր ծրագիրը պետք է կառուցվածք ունենա, երբ Vue ավելի ճկուն, մոդուլար լուծում է։ Սա Vue-ին թույլ է տալիս լինել ավելի ադապտացվող մի շարք նախագծերի համար, մենք նաև ճանաչում ենք որ մեկմեկ օգտակար է ունենալ որոշ որոշումներ ձեզ համար, որ դուք ուղղակի սկսեք կոդավորել։

Սա է պատճառը թե խի ենք մենք առաջարկում ամբողջովին համակարգ Vue.js-ի արագ զարգացման համար։ [Vue CLI-ը](https://github.com/vuejs/vue-cli) որը նախատեսված է որպես ստանդարտ գործիքների հիմք Vue-ի էկոհամակարգի համար։ Այն համոզվում է որ տարբեր build-ների գործիքները աշխատենք ստաբիլ և արագ միաժամանակ խելամիտ նախընտրանքներով որ դուք կարողանաք կենտրոնանաք գրել ձեր ծրագիրը ի փոխարեն ծախսելով ժամեր տանջվելով կոնֆիգուրացիայի հետ։ Նույն ժամանակ, այն առաջարկում է ճկունությունը որպեսզի փոփոխեք կոնֆիգուրացիան ամեն գործիքի ըստ ձեր հարմարության։

### Տվյալների կապում

AngularJS-ը օգտագործում է երկուղի կապում scope-երի միջև, երբ Vue-ն ապահովում է մեկ-ուղի տվյալների հոսք կոմպոնենտների միջև։ Սա հեշտացնում է տվյալների հոսքը թեթև ծրագրերում։

### Ուղղորդիչներ ընդեմ Կոմպոնենտների

Vue-ն ունի պարզ բաժանում ուղղորդիչների և կոմպոնենտների միջև։ Ուղղորդիչները նախատեսված են կոպսուլացնելու DOM-ի մանիպուլատորները միայն, երբ կոմպոնենտները ինքնամփոփ բաժիններ են որոնք ունեն տեսքի և տվյալների տրամաբանությունը։ AngularJS-ում, ուղղորդիչները անում են ամենինչ և կոմպոնենտները ուղղորդիչների մի տեսակ են։

### Runtime-ի Կատարումը

Vue-ն ունի ավելի լավ կատարում և այն շատ, շատ հեշտ է օպտիմիզացելու որովհետև այն չի օգտագործում dirty checking։ AngluarJS դանդաղանում է երբ կան շատ watcher-ներ, որովհետև ամեն անգամ ամենինչ scope-ի մեջ փոխվում է, բոլոր այս watcher-ները պետք է նորից հաշվարկվեն։ Նաև, ցիկլերը պետք է աշխատեն միքանի անգամ որպեսզի "կայունացնեն" եթե ինչ որ watcher կանչում է թարմեցման պրոցեսը։ AngularJS-ի օգտագործողները ստիպված են լինում դիմել էզոթերային տեխնիկայի որպեսզի շրջանցեն digest ցիկլը, և որոշ պայմաններում, հնարավոր չի լինում օպտիմիզացնելու scope-երը շատ watcher-ների հետ։

Vue-ն չունի նման բաներ որովհետև այն օգտագործում է թափանցիկ dependency-tracking դիտարկման համակարգ async հերթով - բոլոր փոփոխությունները կանչվում են ինքնուրույն եթե նրանք չունեն բացառիկ dependecy-ի հարաբերություններ։

Հետաքրքրորեն, կան մի քանի նմանություններ թե ինչպես են Angular-ը և Vue-ն անդրադառնում այս AngularJS-ի խնդիրներին։

## Angular (Նախկինում որպես Angular 2)

Մենք ունենք առանձին բաժին նոր Angular-ի համար որովհետև այն իրոք լիովին տարբերվող framework է ի համեմատ AngularJS-ի։ Օրինակ՝ այն առաջակում է first-class կոմպոնենտի համակարգ, շատ տեղադրման մանրամասներ ամբողջովին նորից են գրվել, և API-ը նույնպես կտրուկ փոփոխվել է։

### TypeScript

Angular-ը ըստ էության պահանջում է TypeScript, հաշվի առնելով, որ գրեթե բոլոր փաստաթղթերը և ուսումնական ռեսուրսները TypeScript-ի վրա են հիմնված։ TypeScript-ը ունի իր օգուտները - static type ստուգումը կարող է լինել շատ օգտակար մեծ ծավալի ծրագրերի համար, և կարող է լինել մեծ արտադրության օգուտ այն ծրագրավորողների համար ովքեր նախկինում աշխատել են Java-ով և C#-ով։

Սակայն, ոչ բոլորն են ուզում օգտագործեն TypeScript: Շատ փոքր ծավալի օգտագործման դեպքերում, ներկայացնելով տիպի համակարգը կարող է արդյունքում ավելի ծանրակշռել քան արտադրության մեջ շահույթ ցուցաբերել։ Այս դեպքերում ձեզ ավելի լավ կլինի օգտագործել Vue-ն, որովհետև օգտագործելով Angular-ը առանց TypeScript-ի կարող է լինել դժվար։

Վերջապես, չնայած ոչ այնքան խորը ինտեգրված չէ TypeScript-ի հետ, որքան Angular-ը, Vue-ն առաջարկում է [official typings](https://github.com/vuejs/vue/tree/dev/types) և [official decorator](https://github.com/vuejs/vue-class-component) նրանց համար ովքեր ուզում են օգտագործել TypeScript Vue-ի հետ։ Մենք նաև ակտիվորեն համագործակցում ենք TypeScript և VSCode թիմերի հետ Microsoft-ում որպեսզի բարելավենք TS/IDE փորձը Vue + TS օգտագործողների համար։

### Runtime-ի Կատարումը

Երկու framework-երը բացառապես արագ են, շատ հաշվարկված նմանություններով։ Դուք կարող նայել [բրաուզերի հատուկ չափումները](https://stefankrause.net/js-frameworks-benchmark8/table.html) ավելի մանրամասը համեմատության համար, բայց արագությունը չի լինի որոշող մասնիկ այս դեպքում։

### Չափս

Նոր տարբերակներում Angular-ի, [AOT compilation-ի](https://en.wikipedia.org/wiki/Ahead-of-time_compilation) և [tree-shaking-ի](https://en.wikipedia.org/wiki/Tree_shaking) հետ, հաջողվել է իջեցնել նրա չափսը զգալիորեն։ Սակայն, բոլոր-հատկություններով Vue 2 նախագիծը Vuex + Vue Router ներառյալ (~30KB gzipped) համեմատորեն շատ թեթև է ի համեմատ AOT-compile եղած ծրագրի որը գեներացվել է `angular-cli`-ով (~65KB gzipped):

### Ճկունությունը

Vue-ն ավելի քիչ սահմանափակումներ ունի քան Angular-ը, առաջարկելով պաշտոնական աջակցություն տարբեր համակարգերի կառուցման համար, առանց արգելակելու թե ինչ կառուցվածք պետք է ձեր ծրագիրը ունենա։ Շատ ծրագրավորողներ վայելում են այս ազատությունը, և որոշները նախընտրում են ունենալ միայն մեկ ճիշտ ձև կառուցելու ցանկցած ծրագիր։

### Սովորելու Դժվարությունը

Որ սկսեք Vue-ի հետ, այն ինչ որ ձեզ պետք է դա որոշ ծանոթություն է HTML-ի և ES5 JavaScript-ի հետ (չոր JavaScript)։ Այս սովորական հմություններով, դուք կարող եք կառուցել հասարակ ծրագրեր մեկ օրվա [ուղեցույցի](./) ուսումնասիրությամբ։

Angular-ին սովորելը ավելի դժվար է։ API-ի մակերեսը framework-ի շատ հսկայական է և որպես օգտագործող դուք պետք է ծանոթանաք շատ հասկացությունների հետ նախքան դուք կարող եք լինել արտադրողական։ Angular-ի դժվարության պատճառը հիմնականում նրա ոճն է որը կենտրոնացված է միայն մեծ, բարդ ծրագրերի վրա - բայց սա չի բարդացնի framework քիչ փորձ ունեցող ծրագրավորողների համար։

## Ember

Ember-ը հատկություններով լի framework է որը դիզայնավորված որ լինի շատ սահմանափակ։ Այն առաջարկում է շատ հաստատված կոնվենցիաներ և երբ որ դուք արդեն ծանոթանաք նրանց հետ բավականին, այն կարող է ձեզ շատ արտադրողական դարձնել։ Սակայն, դա նաև նշանակում է որ սովորելը բավականին դժվար է և ճկունությունը ցածրանում է։ Սա հակասվում է երբ որ դուք փորձում եք վերցնել սահմանափակ framework—ի և գրադարանի և թույլ կապված գործիքների հավաքածուների միջև։ Ոչ մեկն էլ չի տրամադրի ձեզ շատ ազատություն փոխարենը այն կպահանջի ձեզ կատարել ավելի ծարտարագիտական որոշումներ։

Դա ասված, կարող է դարձնել ավելի լավ համեմատություն Vue-ի core-ի և Ember-ի [ձևանմուշային](https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/) և [օբյեկտ մոդելի](https://guides.emberjs.com/v2.10.0/object-model/) շերտերին։

- Vue-ն տրամադրում է աննկատելի ռեակտիվություն պարզ JavaScript օբյեկտներով և ամբողջովին ավտոմատացված հաշվարկված հատկություններով։ Ember-ում, դուք պետք է փաթաթեք ամենինչ Ember-ի օբյեկտնորւմ և ձեռքով հայտարարեք dependency-ները հաշվարկված հատկությունների համար։

- Vue-ի ձևանմուշի գրելաձևը ստանում է JavaScript-ի արտահայտությունների ամբողջ ուժը, երբ Handlebar-ի՝ արտահայտություննը և օգնական գրելաձևը դիտավորյալ շատ սահմանափակ է երբ համեմատում ենք։

- Կատրման ժամանակ, Vue-ն գերազանցում է Ember-ին արագությամբ [արդար ձևով](https://stefankrause.net/js-frameworks-benchmark8/table.html), և նույնիսկ Glimmer engine-ի թարմեցումից հետո Ember 3.x-ում։ Vue-ն ավտոմատ կերով թարմեցվում է, երբ Ember-ում դուք պետք է ձեռքով կառավարեք ցիկլերը կատարման-կրիտիկական իրավիճակներում։

## Knockout

Knockout-ը առաջատար էր MVVM-ում և նրա dependency tracking-ը և ռեակտիվության համակարգը շատ նման է Vue-ինին։ Նրա [բրաուզերի համապատասխանեցումը](http://knockoutjs.com/documentation/browser-support.html) նաև շատ տպավորիչ համարելով այն ամենը, ինչ անում է նա, ունի համապատասխանեցում մինչև IE6! Vue-ն միայն համապատասխանում է IE9+։

Ժամանակի ընթացքում, Knockout-ի զարգացումը դանդաղացել է և սկել է ցույց տալ իր տարիքը միքիչ։ Օրինակ, նրա կոմպոնենտի համակարգը չունի աբողջովին lifecycle hook-երի հավաքածու որը շատ տարածված է օգտագործման մեջ, նախատեսված ինտերֆայսը որը փոխանցում է ժառանգող կոմպոնենտին, զգացվում է մի փոքր անփույթ համեմատած [Vue-ինին](components.html#Content-Distribution-with-Slots)։

Կան նաև փիլիսոփայական տարբերություններ API-ի ոճի մեջ եթե դուք հետաքրքրված եք, կարելի է ցույց տալ, թե ինչպես է յուրաքանչյուրը ղեկավարում [հասարակ todo list-ի](https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89) ստեղծումը։

## Polymer

Polymer-ը մեկ ուրիշ Google-ով հովանավորված նախագիծ է և այն հանդիսացել է ոգեշնչիչ Vue-ի համար։ Vue-ի կոմպոնենտները կարող են հեռավոր համեմատվել Polymer-ի custom էլեմենտների հետ և երկուսնել տրամադրում են շատ նման զարգացման ոճ։ Ամենամեծ տարբերությունը դա երբ Polymer-ը կառուցված է ամենավերջին Web Կոմպոնենտների հատկություններով և պահանջում է որոշ polyfill-ներ որպեսզի աշխատի (դեգրադացված կատարումով) բրաուզերների մեջ որոնք չունեն համապատասխանեցում։ Կոնտրաստային նայելով, Vue-ն աշխատում է առանց որև պահանջարկների կամ polyfill-ների միչև IE9:

Polymer-ում, թիմը իր տվյալների կամպան համակարգը շատ սահմանափակ է կառուցել որպեսզի կատարումը ավելի արագացնի։ Օրինակ՝ այն արտահայտությունները որոնք կան Polymer-ի ձևանմուշներում դա boolean է և մեկ մեթոդ կանչերը։ Նրա հաշվարկված հատկությունների տեղադրումը շատ ճկուն չէ։

## Riot

Riot 3.0-ը տրամադրում է նման կոմպոնենտով օժտված զարգացման մոդել (որը անվանված է որպես "tag" Riot-ում), որը ունի նաև մինիմալ և գեղեցիկ դիզայնավորված API: Riot-ը և Vue-ն հավանաբար ունեն շատ նմանություններ դիզայի փիլիսոփայության մեջ։ Սակայն, լինելով միքիչ ծանր քան Riot-ը, Vue-ն առաջարոկում է շատ բարելավումներ։

- Կատարմամբ. Riot [անցնում է DOM-ի ծառի](https://v3.riotjs.now.sh/compare/#virtual-dom-vs-expressions-binding) միջով այլ ոչ թե օգտագործելով virtual DOM, ունի նույն կատարման խնդիրները ինչպիսիք էին AngularJS-ում։
- Ավելի զարգացված գործիքներ։ Vue-ն տրամադրում է պաշտոնական աջակցություն [webpack-ի](https://github.com/vuejs/vue-loader) և [Browserify-ի](https://github.com/vuejs/vueify) համար, երբ Riot-ը ապավինում է համայնքի աջակցության կառուցման համակարգի ինտեգրացման համար։
