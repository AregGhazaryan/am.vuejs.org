---
title: Ռեակտիվությունը Խորացված
type: ուղեցույց
order: 601
---

Հիմա ժամանակն է որպեսզի ավելի կենտրոնանալ։ Vue֊ի ամենա հատուկ հատկանիշներից մեկն դա իր ռեակտիվության համակարգն է։ Մոդելները ուղղակի հասարակ JavaScript օբյեկտներ են։ Երբ որ դուք փոփոխում եք նրանց, տեսադաշտը թարմացվում է։ Այն դարձնում է state֊ի կառավարումը ավելի պարզ և կանխագուշակելի, բայց կարևոր է իմանալ թե ինչպես է այն աշխատում որպեսզի խուսափել որոշ հիմնական սխալներից։ Այս բաժինում, մենք ավելի մանրամասն ենք զննելու Vue֊ի ռեակտիվության համակարգի ցածր կարգի մասերը։

<div class="vue-mastery"><a href="https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system" target="_blank" rel="sponsored noopener" title="Vue Reactivity">Դիտեք այս բացատրող տեսանյութը Vue Mastery֊ում</a></div>

## Ինչպես են Փոփոխությունները Դիտարկվում

Երբ դուք փոխանցում եք պարզ JavaScript օբյեկտ Vue instance֊ին որպես իր `data` ընտրանք, Vue֊ն կանցնի իր բոլոր հակություններով և կվերափոխի նրանց դեպի [getter/setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters) օգտագործելով [`Object.defineProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)։ Սա միայն ES5 և անշուք հատկություն է, որի պատճառով Vue֊ն չի համապատասխանում IE8֊ին և ավելի ցածր։

Getter/setters֊ները անտեսանելի են օգտագործողին, բայց ներքինում նրանք թույլ են տալիս Vue֊ին որպեսզի կատարել dependency-tracking և change-notification երբ հատկությունները օգտագործվել կամ փոփոխվել են։ Մեկ դեպքն է երբ բրաուզերի console֊ները վերափոխում են getters/setters֊ները տարբերվող ձևով երբ փոփոխված օբյեկտները log են եղած, այնպես որ դուք հնարավոր է որ կցանկանաք տեղադրել [vue-devtools](https://github.com/vuejs/vue-devtools) զննման և ավելի հարմար ինտերֆայսի համար։

Ամեն կոմպոնենտի instance ունի համապատասխան **watcher**  instance֊ը, որը դիտարկում է ցանկացած հատկությունները որոնք «դիպվել» են կոմպոնենտի render֊ի ժամանակ որպես dependency։ Հետո երբ dependency֊ի setter֊ը արձակված է, այն տեղյակ է պահում watcher֊ին, որը իր հերթին ստիպում է կոմպոնենտին որպեսզի re-render կատարի։

![Ռեակտիվության Ցիկլ](/images/data.png)

## Փոփոխությունների Հայտնաբերման Դեպքեր

JavaScript֊ի սահմանափակումների պատճառով, կան մի քանի տիպի փոփոխություններ որոնց Vue֊ն **չի նկատում**։ Սակայն, կան շրջանցելու ճանապարհներ որպեսզի պահպանել ռեակտիվությունը։

### Օբյեկտների Համար

Vue֊ն չի կարող նկատել հատկության ավելացնումը և կամ ջնջումը։ Մինչ Vue֊ն կատարում է getter/setter֊ների վերափոխման պրոցես instance֊ի սկսզբում, հատկությունը պետք է ներկա լինի `data` օբյեկտում որպեսզի Vue֊ն նրանց վերափոխի և դարձնի ռեակտիվ։ Օրինակի համար,

``` js
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a`֊ը հիմա ռեակտիվ է

vm.b = 2
// `vm.b`֊ը ռեակտիվ չէ
```

Vue֊ն թույլ չի տալիս դինամիկորեն ավելացնել արմատային մակարդակի ռեակտիվ հատկություններ արդեն ստեղծված instance֊ին։ Սակայն, հնարավոր է ավելացնել ռեակտիվ հատկություններ ներքին օբյեկտին օգտագործելով `Vue.set(object, propertyName, value)` մեթոդը․

``` js
Vue.set(vm.someObject, 'b', 2)
```

Դուք նաև կարող եք օգտագործել `vm.$set` instance֊ի մեթոդը, որը փոխանուն է համարվում գլոբալ `Vue.set`֊ի համար․

``` js
this.$set(this.someObject, 'b', 2)
```

Երբեմն դուք կցանկանաք վերագրել մի քանի հատկություններ գոյություն ունեցող օբյեկտին, օրինակ օգտագործելով `Object.assign()` or `_.extend()`։ Սակայն, նոր հատկությունները որոնք ավելացվել են օբյեկտին չեն արձակի փոփոխությունները։ Այս դեպքերում, ստեղծեք նոր օբյեկտ հին և նոր հատկությունների հետ հանդերձ․

``` js
// `Object.assign(this.someObject, { a: 1, b: 2 })`֊ի փոխարեն
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

### Զանգվածների Համար

Vue֊ն չի կարող նկատել հետևյալ փոփոխությունները զանվածում․

1. Երբ որ դուք ուղիղ տեղադրում եք մասնիկ index֊ի հետ օրինակ՝ `vm.items[indexOfItem] = newValue`
2. Երբ որ դուք փոփոխում եք զանգվածի երկարությունը օրինակ՝ `vm.items.length = newLength`

Օրինակի համար․

``` js
var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' //  ռեակտիվ չէ
vm.items.length = 2 // ռեակտիվ չէ
```

Որպեսզի առաջին օրինակը շրջանցենք, այս երկու օրինակներնել կհասնեն նույնին ինչ `vm.items[indexOfItem] = newValue` է, բայց նաև կարձակեն state֊ի թարմացումներ ռեակտիվության համակարգում․

``` js
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
```
``` js
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```

Դուք նաև կարող եք օգտագործել [`vm.$set`](https://vuejs.org/v2/api/#vm-set) instance֊ի մեթոդը, որը փոխանուն է գլոբալ `Vue.set`֊ի համար․

``` js
vm.$set(vm.items, indexOfItem, newValue)
```

Որպեսզի շրջանցել երկրորդ օրինակը, դուք կարող եք օգտագործել `splice`․

``` js
vm.items.splice(newLength)
```

## Ռեակտիվ Հատկությունների Հայտարարումը

Մինչ Vue-ն թույլ չի տալիս դինամիկորեն ավելացնել արմատային աստիճանի ռեակտիվ հատկություններ, դուք պետք է հայտարարեք բոլոր արմատային աստիճանի ռեակտիվ հատկությունները Vue֊ի instance-ները ստեղծելու ժամանակ, նույնիսկ դատարկ արժեքով․

``` js
var vm = new Vue({
  data: {
    // հայտարարեք message֊ը դատարկ արժեքով
    message: ''
  },
  template: '<div>{{ message }}</div>'
})
// տեղադրեք `message`֊ի արժեքը հետո
vm.message = 'Hello!'
```

Եթե դուք չհայտարարեք `message`֊ը data ընտրանքում, Vue֊ն կզգուշացնի ձեզ որ render ֆունկցիան փորձում է օգտագործել հատկությունը որը գոյություն չունի։

Կան տեխնիկական պատճառներ այս արգելափակման վերաբերյալ ֊ այն վերացնում է որոշ բացառիկ դեպքերը dependency֊ի վերահսկման համակարգում, և նաև դրաձնում է Vue֊ի instance֊ները ավելի լավը տիպերի ստուգման համակարգերի համար։ Բայց գոյություն ունի նաև կարևոր դիտողություն կոդի պահպանման համար․ `data` օբյեկտը սխեման է ձեր կոմպոնենտի state֊ի։ Հայտարարելով բոլոր ռեակտիվ հատկությունները սկզբում դարձնում է ձեր կոմպոնենտի կոդը ավելի հեշտ հասկանալու համար երբ այլ ծրագրավորող կկարդա այն։

## Async Թարմացման Հերթը

Եթե դուք դեռ չեք նկատել, Vue֊ն կատարում է DOM թարմացումներ **ասինխռոն**  կերպով։ Երբ տվյալի փոփոխություն է դիտարկվում, այն կբացի նոր հերթ և կտեղադրի բոլոր տվյալների փոփոխությունները որոնք կատարվում են նույն event֊ի ցիկլում։ Եթե նույն դիտարկողը արձակվել է մի քանի անգամ, այն կտեղադրվի հերթում միայն մեկ անգամ։ Այս բեռնված կրկնօրինակման չեղարկումը  կարևոր է որպեսզի խուսափել անիմաստ հաշվարկումներից և DOM֊ի մանիպուլացիաներից։ Այնուհետև, հաջորդ event֊ի ցիկլի «tick»֊ում, Vue֊ն ջնջում է հերթը և կատարում է նոր մաքրված հերթագրված աշխատանքները։ Ներքինում Vue֊ն փորձում է `Promise.then`, `MutationObserver`, և `setImmediate` ասինխռոն հերթագրման համար և խնդիրների դեպքում ետ կգա դեպի `setTimeout(fn,0)`:

Օրինակի համար, երբ դուք տեղադրում եք `vm.someData = 'new value'`, կոմպոնենտը անմիջապես re-render չի կատարի։ Այն կթարմացնի հաջորդ «tick»֊ում, երբ հերթը ջնջված է։ Շատ դեպքերում մեզ հարկավոր չէ սա, բայց այն կարող է լինել բարդ երբ որ դուք ցանկանում եք մի բան անել ինչը որ կախված է DOM֊ի state֊ի թարմացումից հետո։ Չնայած որ Vue.js֊ը հիմնականում խրախուսում է որպեսզի ծրագրավորողները մտածեն տվյալներով հիմնված կերպով և չդիպչեն DOM֊ին ուղիղ, երբեմն հնարավոր որ հարկավոր լինի ձեր ձեռքերը կեղտոտել։ Որպեսզի սպասել մինչ Vue.js֊ը վերջացնի DOM֊ի թարմացումը տվյալների փոփոխումից հետո, դուք կարող եք օգտագործեք `Vue.nextTick(callback)` անմիջապես հենց տվյալները փոփոխվել են։ Այս callback֊ը կկանչվի DOM֊ի թարմացումից հետո։ Օրինակի համար․

``` html
<div id="example">{{ message }}</div>
```

``` js
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'new message' // տվյալի փոփոխություն
vm.$el.textContent === 'new message' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'new message' // true
})
```

Կա նաև `vm.$nextTick()` instance մեթոդը, որը հատկապես օգտակար է կոմպոնենտների ներսում, որովհետև այն չի պահանջում գլոբալ `Vue`֊ն և իր callback֊ները, `this` context֊ը ավտոմատ կերպով կկապվի ընթացիկ Vue instance֊ին․

``` js
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: 'չի թարմացվել'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = 'թարմացվել է'
      console.log(this.$el.textContent) // => «չի թարմացվել»
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => «թարմացվել է»
      })
    }
  }
})
```

Մինչ `$nextTick()`֊ը վերադարձնում է promise, դուք կարող եք հասնել վերևում նշված արդյունքին օգտագործելով նոր [ES2017 async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) գրելաձևը․

``` js
  methods: {
    updateMessage: async function () {
      this.message = 'updated'
      console.log(this.$el.textContent) // => «չի թարմացվել»
      await this.$nextTick()
      console.log(this.$el.textContent) // => «թարմացվել է»
    }
  }
```
