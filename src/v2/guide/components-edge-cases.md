---
title: Բացառիկ դեպքերի կառավարումը
type: guide
order: 106
---

> Այս էջը ենթադրում է որ դուք արդեն կարդացել եք [Կոմպոնենտների Հիմունքները](components.html)։ Կարդացեք այն եթե դուք նոր եք ծանոթանում կոմպոնենտներին։

<p class="tip">Այս էջի բոլոր առանձնահատկությունները փաստում են բացառիկ դեպքերի կառավարումը, ինչը նշանակում է անսովոր իրավիճակներ, որոնք երբեմն պահանջում են փոքր-ինչ թեքել Vue-ի կանոնները: Սակայն նշում, որ բոլորն էլ ունեն թերություններ կամ իրավիճակներ, որտեղ դրանք կարող են վտանգավոր լինել: Նրանք յուրաքանչյուր դեպքում նշվում են, այնպես որ յուրաքանչյուր առանձնահատկություն ընտրելու որոշում կայացնելիս հիշեք դրանք։</p>

## Էլեմենտի և Կոմպոնենտի Մուտք

Որոշ դեպքերում, ամենալավ տարբերակն է խուսափել այլ կոմպոնենտի instance-ի մեջ մտնելը կամ ձեռքով մանիպուլացիայի եթարկելու DOM էլեմենտները։ Այնուամենայնիվ, կան դեպքեր, երբ դա կարող է տեղին լինել։

### Մուտք Գործումը դեպի Root Instance

Ամեն սուբկոմպոնենտում `new Vue`-ի instance, մենք կարող ենք մուտք գործել այս root instance `$root` հատկությունով։ Օրինակ՝, այս root instance—ում։

```js
// Vue-ի root instance-ը
new Vue({
  data: {
    foo: 1
  },
  computed: {
    bar: function () { /* ... */ }
  },
  methods: {
    baz: function () { /* ... */ }
  }
})
```

Բոլոր սուբկոմպոնենտները հիմա կարող ենք մուտք գործել այս instance և օգտագործել այն որպես գլոբալ պահեստ:

```js
// Ստանալ root տվյալները
this.$root.foo

// Վերագրել root տվյալները
this.$root.foo = 2

// Մուտք գործել դեպի root հաշվարկված հատկություններ
this.$root.bar

// Կանչել root մեթոդներ
this.$root.baz()
```

<p class="tip">Սա կարող է հարմար լինել demo կամ փոքր ծրագրերի համար որոնք ունեն բազմաթիվ կոմպոնենտներ։ Սակայն, այս pattern-ը լավ աճ չունի դեպի միջին կամ ավելի մեծ ծրագրեր, մենք խորհուրդ ենք տալիս օգտագործել <a href="https://github.com/vuejs/vuex">Vuex</a> որպեսզի կառավարել վիճակը (state-ը) որոշ դեպքերում։</p>

### Մուտք Դեպի Ծնող Կոմպոնենտի Instance

Նման `$root`-ին, `$parent` հատկությունը կարող է օգտագործվել որպեսզի մուտք գործել ծնող instance ժառանգողից։ Սա գայթակղիչ կարող է լինել որպես ալարկոտ այլընտրանք որպեսզի տվյալներ փոխանցել հատկության հետ համատեղ։

<p class="tip">Շատ դեպքերում, մուտք գործելով դեպի ծնող դարձնում է ձեր ծրագիրը ավելի դժված debug անելու և հասկանալու համար, հատկապես երբ որ մուտացնում եք տվյալները ծնողի մեջ։։ Երբ նայում եք այդ կոմպոնենտին հետո, շատ դժվար կլինի պարզելու թէ որտեղից է մուտացիան առաջացել։</p>

Այդ դեպքերը սակայն, մասնավորապես ընդհանուր կոմպոնենտի գրադարանների համար, _կարող_ է լինել համապատասխան։ Օրինակ՝ աբստրակտ կոմպոնենտները կարող են շփվել JavaScript API-ների հետ ի փոխարեն HTML-ը render անելու, ինչպես այս վարկածային Google Maps-ի կոմպոնենտները։

```html
<google-map>
  <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
</google-map>
```

`<google-map>` կոմպոնենտը կարող է նկարագրել `map` հատկություն որին բոլոր սուբկոմպոնենտները պետք է կարողանան մուտք գործել։ Այս դեպքում `<google-map-markers>` անհրաժեշտության դեպքում պետք է մուտք գործի դեպի map այս ձևով `this.$parent.getMap`, որպեսզի ավելացնի marker-ների հավաքածու։ Դուք կարող եք ուսումնասիրել այս pattern-ի [գործողությունը այստեղ](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance)։

Մտքում պահեք, որ այս կոմպոնենտները որոնք կառուցվել են այս pattern-ի շնորհիվ ժառանգականորեն փխրուն են։ Օրինակ՝ պատկերացրեք որ մենք ավելացնում ենք նոր `<google-map-region>` կոմպոնենտ և երբ `<google-map-markers>`-ը հայտնվում է իր մեջ, այն միայն պետք է render անի marker-ները որոնք այդ շրջանի մեջ են։

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

Այնուհետև `<google-map-markers>`-ում դուք հնարավոր է որ կկիրառեք այսպիսի մի բան։

```js
var map = this.$parent.map || this.$parent.$parent.map
```

Սա արագորեն ձեռքից դուրս է գալիս։ Դրա համար մենք առաջարկում ենք ենթատեքստային տեղեկատվություն ժառանգական կոպմոնենտների մասին, փոխարենը խորհուրդ ենք տալիս [dependency injection-ը](#Dependency-Injection)։

### Մուտք Գործելով Ժառանգող Կոմպոնենտի Instance-ներ և Ժառանգող Էլեմենտներ

Չնայած հատկությունների և event-ների գոյությանը, երբեմն դուք հնարավոր է որ կցանկանաք ուղիղ մուտք գործել ժառանգող կոմպոնենտ JavaScript-ում։ Որպեսզի հասնել դրան դուք պետք է նշանակեք reference ID ժառանգող կոմպոնենտին օգտագործելով `ref` ատրիբուտը։
Օրինակ՝

```html
<base-input ref="usernameInput"></base-input>
```

Հիմա երբ որ դուք կոմպոնենտում նկարագրել եք այս `ref`-ը, դուք կարող եք օգտագործել։

```js
this.$refs.usernameInput
```

Որպեսզի մուտք գործել դեպի `<base-input>` instance։ Սա կարող է օգտակար լինել երբ որ դուք, օրինակի համար, ծրագրավորման միջոցով focus եք անում այս input-ի վրա ծնողից։ Այս դեպքում, `<base-input>` կոմպոնենտը նմանորեն կարող է օգտագործել `ref`-ը որպեսզի տրամադրել մուտք հատուկ էլեմենտների ներսում, ինչպիսիք են։

```html
<input ref="input">
```

ԵՎ նույնիսկ նկարագրել մեթոդներ այս ծնողի համար։

```js
methods: {
  // Օգտագործվում է որպեսզի focus տրամադրել input-ին ծնողի կողմից
  focus: function () {
    this.$refs.input.focus()
  }
}
```

Սրանով մենք թույլ ենք տալիս ծնող կոմպոնենտին որպեսզի կենտրոնանա input-ի վրա `<base-input>`-ի մեջ։

```js
this.$refs.usernameInput.focus()
```

Երբ `ref`-ը օգտագործվում է համատեղ `v-for`-ի հետ, ref-ը որը դուք կստանաք կլինի զանգված որը պարունակում է ժառանող կոմպոնենտները իր տվյալների աղբյուրով։

<p class="tip"><code>$refs</code> միայն առանջանում են երբ կոմպոնենտը render է եղել, և նրանք ռեակտիվ չեն։ Այն նախատեսված է միայն որպես այլ տարբերակ ուղիղ ժառանգողի մանիպուլացիային համար - դուք պետք է խուսափեք մուտք գործելու դեպի <code>$refs</code> ձևանմուշի կամ հաշվարկված հատկությունների ներքո։</p>

### Dependency Injection

Ավելի վաղ, մենք նկարագրել էինք [Մուտք Դեպի Ծնող Կոմպոնենտի Instance](#Accessing-the-Parent-Component-Instance), մենք ցույց ենք տվել հետևյալ օրինակը։

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

Այս կոմպոնենտում, բոլոր ժառանգողները `<google-map>`-ի անհրաժեշտ էին մուտք գործելու դեպի `getMap` մեթոդ, որպեսզի իմանանք թէ որ քարտեզի հետ շփվենք։ Ցավոք, օգտագործելով `$parent` հատկությունը մենք չենք կարող խորանալ կոմպոնենտի մեջ ավելի մանրամասն։ Այստեղ մենք կոգտագործենք dependency injection-ը որը կարող է օգտակար լինել, օգտագործելով երկու նոր instance ընտրանքներ․ `provide` և `inject`:

`Provide` ընտրանքը մեզ թույլ է տալիս հատուկ տվյալներ/մեթոդներ **տրամադրել** ժառանգող կոմպոնենտներին։ Այս դեպքում, դա `getMap` մեթոդն է `<google-map>`-ի մեջ։

```js
provide: function () {
  return {
    getMap: this.getMap
  }
}
```

Այնուհետև ցանկացած ժառանգողում, մենք կարող ենք օգտագործել `inject` ընտրանքը որպեսզի ստանանք կոնկրետ հատկություններ որոնք մենք ցանկանում ենք ավելացնել այդ instance-ին։

```js
inject: ['getMap']
```

Դուք կարող էք նայել [օրինակը ամբողջովին այստեղ](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection)։ Առավելությունը օգտագործելով `$parent`-ը մենք կարող ենք մուտք գործել `getMap` _ցանկացած_ ժառանգող կոմպոնենտում, առանց բացահայտելու `<google-map>`-ի ամբողջ instance-ը։ Սա մեզ թույլ է տալիս ավելի ապահով զարգացնել այդ կոմպոնենտը, առանց վախի որ մենք հնարավոր է որ փոխենք/ջնջենք որևէ մի բան որից այդ ժառանգող կոմպոնենտը կախված է։ Կոմպոնենտների միջև գտնվող Interface-ը մնում է պարզ նկարագրված, ինչպես `props`-ի հետ։

Իրականում, դուք կարող եք մտածել dependency injection-ի մասին ինչպես "հավելյալ հատկություններ", բացառությամբ։

* ծնող կոմպոնենտը չ՛պետք է իմանա թե որ ժառանգողներն են օգտագործում այն հատկությունները որոնք այն տրամադրում է
* ժառանգող կոմպոնենտները չ՝պետք է իմանան թե որտեղից են injected հատկությունները գալիս

<p class="tip">Սակայն, dependency injection-ը ունի որոշ վատ կողմեր։ Այն զուգում է կոմպոնենտները ձեր ծրագրում ինչպես նրան կազմակերպված են, դարձնելով refactoring-ը ավելի դժվար։ Տրամադրված հատկությունները նաև ռեակտիվ չեն։ Սա նրա ոճից է, որովհետև այն օգտագործվում է որպեսզի ստեղծել վատ կենտրոնական տվյալների պահեստ ինչպես <a href="#Accessing-the-Root-Instance">օգտագործելով <code>$root-ը</code></a> նույն նպատակի համար։ Եթե հատկությունները դուք ցանկանում եք տրամադրել հատուկ են ծրագրի համար սովորականի փոխարեն, կամ եթե դուք ցանկանաք թարմացնել տրամադրված տվյալները ծնողում, այդ դեպքերում ձեզ հաստատ պետք կգա իրական state managment-ի լուծում ինչպիսին է <a href="https://github.com/vuejs/vuex">Vuex-ը</a>։</p>

Իմացեք ավելին dependency injection-ի մասին [API-ի փաստաթղթում](https://vuejs.org/v2/api/#provide-inject)։

## Ծրագրավորված Event-ի Լսողներ

Մինչ այժմ, դուք տեսել եք թե ինչպես են օգտագործում `$emit`-ը, լսված `v-on`-ի շնորհիվ, բայց Vue-ի instance-ները կարող են նաև տրամադրել այլ մեթոդներ իր event-ների interface-ի համար։ Մենք կարող ենք․ 

- Լսել event-ին `$on(eventName, eventHandler)`-ի շնորհիվ
- Լսել event-ին միայն մեկ անգամ `$once(eventName, eventHandler)`-ի շնորհիվ
- Դադարել լսել event-ին `$off(eventName, eventHandler)`-ի շնորհիվ

Դուք սովորականում չ՛պետք է օգտագործեք դրանք, բայց նրանք հասանելի են որոշ դեպքերում երբ որ դուք ցանկանում եք ձեռքով լսել event-ներին կոմպոնենտի instance-ում։ Նրանք կարող են նաև օգտակար լիենլ որպես կոդը կազմակերպելու գործիք, դուք նաև հաճախ կնկատեք այս pattern-ը երբ որ տեղադրում եք 3-րդ կողմի գրադարան։

```js
// Միացրեք datepicker-ը input-ին մեկ անգամ
// Այդ mount է եղած DOM-ին։
mounted: function () {
  // Pikaday-ը 3-րդ կողմի datepicker գրադարան է
  this.picker = new Pikaday({
    field: this.$refs.input,
    format: 'YYYY-MM-DD'
  })
},
// Հենց մինչև կոմպոնենտը վերացված է,
// նաև վերացնել datepicker-ը։
beforeDestroy: function () {
  this.picker.destroy()
}
```

Սա ունի երկու պոտենցիալ խնդիր։

- Այն պահանջում է հիշացնել `picker`-ը դեպի կոմպոնենտի instance, երբ հնարավոր է միայն lifecycle hook-երը պետք է մուտք գործեն։ Սա շատ վատ չէ, և դա կարելի էր համարել խառնաշփոթ։  
- Մեր կազմակերպված կոդը պահված է բաժանված վիճակում մեր մաքրված կոդից, դարձնելով այն ավելի դժվար որպեսզի ծրագրավորման միջոցով մաքրենք այն ինչ որ մենք հավաքել ենք։

Դուք կարող եք լուծել այս խնդիրները ծրագրավորված listener-ով։

```js
mounted: function () {
  var picker = new Pikaday({
    field: this.$refs.input,
    format: 'YYYY-MM-DD'
  })

  this.$once('hook:beforeDestroy', function () {
    picker.destroy()
  })
}
```

Օգտագործելով այս ստրատեգիան, մենք կարող ենք նաև օգտագործել Pikaday-ը մի քանի input էլեմենտների հետ, և ամեն նոր instance-ը կմաքրի իրեն գործողությունները անելուց հետո։

```js
mounted: function () {
  this.attachDatepicker('startDateInput')
  this.attachDatepicker('endDateInput')
},
methods: {
  attachDatepicker: function (refName) {
    var picker = new Pikaday({
      field: this.$refs[refName],
      format: 'YYYY-MM-DD'
    })

    this.$once('hook:beforeDestroy', function () {
      picker.destroy()
    })
  }
}
```

Նայեք [այս օրինակը](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners) ամբողջ կոդի համար։ Նշում, Սակայն, եթե դուք կատարում եք շատ տեղադրումներ և մաքրում մեկ կոմպոնենտի ներքո, ճիշտ լուծում պարզապես կլինի ավելի մոդուլար կոմպոնենտների ստեղծումը։ Այս դեպքում, մենք խորհուրդ ենք տալիս ստեղծելու վերօգտագործելի `<input-datepicker>` կոմպոնենտ։

Որպեսզի իմանալ ավելին ծրագրավորված listener-ների մասին, նայեք API-ը [Event-ի Instance Մեթոդների համար](https://vuejs.org/v2/api/#Instance-Methods-Events)։

<p class="tip">Նշում որ Vue-ի event-ի համակարգը տարբերվում է բրաուզերի <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget API-ից</a>։ Չնայած որ նրանք աշխատում են նմանորեն, <code>$emit</code>, <code>$on</code>, և <code>$off</code> alias—ներ <strong>չեն</strong> <code>dispatchEvent-ի</code>, <code>addEventListener</code>, և <code>removeEventListener</code> համար։</p>

## Ցիկուլյար Reference-ներ

### Ռեկուրսիվ Կոմպոնենտներ

Կոմպոնենտները կարող են ռեկուրսիվ ձևով գործել իրենց ձևանմուշների մեջ։ Սակայն, նրանք կարող են միայն աշխատել այդ կերպ `name` ընտրանքի միջոցով։

``` js
name: 'unique-name-of-my-component'
```

Երբ որ դուք գրանցում եք կոմպոնենտ գլոբալ կերպով օգտագործելով `Vue.component`-ը, գլոբալ ID-ն ավտոմատ կերպով վերագրվում է որպես կոմպոնենտի `name` ընտրանք։

``` js
Vue.component('unique-name-of-my-component', {
  // ...
})
```

Եթե ուշադիր չեք, ռեկուրսիվ կոմպոնենտները կարող են նաև հանգեցնել անսահման ցիկլերի։

``` js
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

Վերևում նշված կոմպոնենտի արդյունքում կստանաք "max stack size exceeded" սխալ, այնպես որ համոզվեք որ ռեկուրսիվ կանչը պայմանական է (օրինակ՝ օգտագործում է `v-if`-ը որը ի վերջո կդառնա `false`)։

### Ցիկուլյար Reference-ները Կոմպոնենտների Միջև

Եկեք ենթադրենք որ դուք կառուցում եք ֆայլերի ցուցակների ծառ, ինչպես Finder-ում կամ File Explorer-ում։ Դուք հնարավոր է որ կունենաք `tree-folder` կոմպոնենտ այս ձևանմուշի հետ։

``` html
<p>
  <span>{{ folder.name }}</span>
  <tree-folder-contents :children="folder.children"/>
</p>
```

Հետո `tree-folder-contents` կոմպոնենտը այս ձևանմուշի հետ։

``` html
<ul>
  <li v-for="child in children">
    <tree-folder v-if="child.children" :folder="child"/>
    <span v-else>{{ child.name }}</span>
  </li>
</ul>
```

Եթե դուք ուշադիր նայեք, դուք կտեսնեք որ այս կոմպոնենտները իրականում կլինեն մեկը մյուսի ժառանգողը և ծնողը render-ի ծառում - որը լրիվ պարադոքս է! Երբ գրանցում ենք կոմպոնենտներ գլոբալ կերպով `Vue.component`-ի հետ, այս պարադոքսը լուծվում է ձեզ համար ավտոմատ կերպով։ Եթե դա դուք եք, դուք կարող եք դադարեցնել կարդալը այստեղ։

Սակայն, եթե դուք required/import եք անում կոմպոնենտները օգտագործելով __մոդուլի համակարգը__, օրինակ՝ Webpack-ի կամ Browserify-ի շնորհիվ, դուք սխալներ կստանաք։

```
Failed to mount component: template or render function not defined.
```

Որպեսզի բացատրենք թե ինչ է կատարվում, եկեք անվանենք մեր կոմպոնենտները A և B։ Այս մոդուլի համակարգը նկատում է որ նրան հարկավոր է A-ն, բայց սկզբում A-ին անհրաժեշտ է B-ն, բայց B-ին անհրաժեշտ է A-ն, և այլն։ Այն կմնա ցիկլի մեջ, առանց իմանալու թե ինչպես լուծել այս կոմպոնենտը առանց լուծելու մյուսը։ Որպեսզի լուծենք այս խնդիրը, մենք պետք է տանք մոդուլի համակարգին մի կետ որում կհայտարարվի, "A-ին անհրաժեշտ է B-ն _ընդհանուր առմամբ_, բայց այստեղ պետք չե լուծել B-ն առաջինը։"

Մեր դեպքում, եկեք ստեղծենք այդ կետը `tree-folder` կոմպոնենտում։ Մենք գիտենք որ ժառանգողը ստեղծում է պարադոքսը որը `tree-folder-contents` կոմպոնենտն է, մենք կսպասենք մինչև `beforeCreate` lifecycle hook-ը կգրանցի այն։ 

``` js
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default
}
```

Կամ ուրիշ ձև, մենք կարող ենք օգտագործել Webpack-ի ասինխռոն `import` երբ դուք գրանցում եք այդ կոմպոնենտը լոկալ ձևով։

``` js
components: {
  TreeFolderContents: () => import('./tree-folder-contents.vue')
}
```

Խնդիրը լուծվեց!

## Այլընտրանքային Ձևանմուշի Սահմանումներ

### Inline Ձևանմուշներ

Երբ `inline-template` հատուկ ատրիբուտը ներկա է ժառանգող կոմպոնենտում, այդ կոմպոնենտը կօգտագործի իր ներքին բովանդակությունը որպես իր ձևանմուշ, ի փոխարեն վերաբերվելու նրան որպես բաշխված բովանդակություն։ Սա մեզ թույլ է տալիս ավելի ճկուն կերպով ձևանմուշը հեղինակել։

``` html
<my-component inline-template>
  <div>
    <p>Սրանք compile են եղած որպես կոմպոնենտի ձևանմուշ։</p>
    <p>Ոչ թե ծնողի փոխակերպման բովանդակություն։</p>
  </div>
</my-component>
```

Ձեր inline ձևանմուշները պետք է նկարագրված լինեն DOM էլեմենտի մեջ որին Vue-ն միացված է։

<p class="tip">Սակայն, <code>inline ձևանմուշը</code> դարձնում է ձևանմուշների scope-ի հետ աշխատելը ավելի դժվար։ Որպես լավագույն փորձ, ցանկալի է նկարագրել ձևանմուշները կոմպոնենտի մեջ օգտագործելով <code>template</code> ընտրանքը կամ <code>&lt;template&gt;</code> էլեմենտը <code>.vue</code> ֆայլի մեջ։</p>

### X-Template

Մեկ այլ ճանապարհ ստեղծելու ձևանմուշներ, script էլեմենտի մեջ `text/x-template` տիպով, երբ դիմում ենք ձևանմուշին id-ով։ Օրինակ՝

``` html
<script type="text/x-template" id="hello-world-template">
  <p>Բարև բարև բարև</p>
</script>
```

``` js
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```

Ձեր x-template-ը պետք է է նկարագրված լինի DOM էլեմենտից դուրս որին Vue-ն է միացված։

<p class="tip">Սա կարող է օգտակար լինել demo-ների համար որոնք ունեն մեծ ձևանմուշներ կամ շատ փոքր ծրագրերում, բայց հակառակ դեպքում պետք է խուսափել, որովհետև նրանք առանձին ձևանմուշներ են ուրիշ նկարագրված ձևանմուշներից։</p>

## Թարմացման Կառավարում

Շնորհակալ լինելով Vue-ի ռեակիվության համակարգին, այն միշտ գիտի թե երբ պետք է թարմացնել (եթե դուք օգտագործում եք այն ճիշտ)։ Կան նաև բացառիկ դեպքեր, սակայն, երբ դուք կցանկանաք ստիպել թարմեցումը, չնայած որ ռեակտիվ տվյալները չեն փոփոխվել։ Այնուհետև կան նաև ուրիշ դեպքեր երբ որ դուք կցանկանաք կանխել ավելորդ թարմացումները։

### Ստիպողական Թարմացում

<p class="tip">Եթե դուք կցանկանաք կատարել ստիպողական թարմացում Vue-ում, 99.99% դեպքերում, դուք ինչ որ մի տեղ սխալ եք արել։</p>

Հնարավոր է ՝ դուք հաշվի չեք առել փոփոխությունների հայտնաբերման նախազգուշացումները [զանգվածներում](https://vuejs.org/v2/guide/list.html#Caveats) կամ [օբյեկտներում](https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats), կամ դուք հնարավոր է որ կախված լինեք այն վիճակի հետ որը չի նկատում Vue-ի ռեակտիվության համակարգը, օրինակ՝ `data`-ն։

Սակայն, եթե դուք կատարել եք վերևում նշվածը և գտնվում եք այս ծայրաստիճան հազվադեպ իրավիճակում որում դուք ցանկանում եք ձեռքով ստիպողականորեն թարմացնել, դուք կարող եք կատարել թարմացումը [`$forceUpdate`](../api/#vm-forceUpdate)-ի շնորհիվ։

### Պարզ Ստատիկ Կոմպոնենտներ `v-once`-ի հետ

Render անելով պարզ HTML էլեմենտները շատ արագ է Vue-ում, բայց երբեմն դուք պետք է ունենաք կոմպոնենտ որը պարունակում է **շատ** ստատիկ բովանդակություն։ Այս դեպքերում, դուք կարող եք համոզվել որ այն միայն հաշվարկված է մեկ անգամ և cache է արված ավելացնելով `v-once` ուղղորդիչը արմատային էլեմենտին, ինչպես հետևյալն է։

``` js
Vue.component('terms-of-service', {
  template: `
    <div v-once>
      <h1>Ծառայությունների մատուցման պայմաններ</h1>
      ... շատ ստատիկ բովանդակություն ...
    </div>
  `
})
```
<p class="tip">ԵՎս մեկ անգամ, փորձեք չվերօգտագործել այս pattern-ը։ Չնայած հարմար է այն հազվագյուտ դեպքերում, երբ դուք ստիպված եք շատ ստատիկ բովանդակություն հաղորդել, այն ուղղակիորեն պարտադիր չէ եթե դուք չեք նկատում դանդաղ rendering -- ի հավելումն, սա կարող է ստեղծել շատ խառնաշփոթներ ավելի ուշ: Օրինակ՝ պատկերացրեք ծրագրավորողի որը ծանոթ չէ <code>v-once</code> կամ պարզապես այն ներկա չէ ձևանմուշում։ Նրանք կարող են ծախսել ժամեր փորձելով հասկանալ թե ինչու ձևանմուշը ճիշտ չի թարմացվում։</p>
