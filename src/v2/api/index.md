---
title: API
type: api
---

## Գլոբալ Կոնֆիգուրացիա

`Vue.config`-ը օբյեկտ է որը պարունակում է Vue-ի գլոբալ կոնֆիգուրացիան։ Դուք կարող եք փոփոխել նրա ներքևում նշված հատկությունները նախքան ձեր ծրագիրը միացնելը։

### silent

- **Տիպ․** `boolean`

- **Հիմնական Արժեքը․** `false`

- **Օգտագործումը․**

  ``` js
  Vue.config.silent = true
  ```

  Արգելափակել Vue-ի բոլոր նախազգուշացումները և log-երը։

### optionMergeStrategies

- **Տիպ․** `{ [key: string]: Function }`

- **Հիմնական Արժեքը․** `{}`

- **Օգտագործումը․**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Սահմանեք custom ձուլման ստրատեգիա ընտրանքի համար։

  Ձուլման ստրատեգիան ստանում է արժեք ընտրանքից որը սահմանված է ծնող և ժառանգող instance-ում որպես առաջին և երկրորդ արգումենտ։ Vue-ի կոնտեքստը փոխանցվում է որպես երրորդ արգումենտ։

- **Նաև նայեք․** [Custom Ընտրանքի Ձուլման Ստրատեգիա](../guide/mixins.html#Custom-Option-Merge-Strategies)

### devtools

- **Տիպ․** `boolean`

- **Հիմնական Արժեքը․** `true` (`false` արտադրության build-ներում)

- **Օգտագործումը․**

  ``` js
  // համոզվեք, որ սա համաժամորեն տեղադրել եք Vue-ն բեռնավորելուց անմիջապես հետո
  Vue.config.devtools = true
  ```

  Դուք նաև կարող եք կոնֆիգուրացիա անել հասանելիությունը [vue-devtools-ի](https://github.com/vuejs/vue-devtools) inspection-ում։ Այս ընտանքի հիմնական արժեքը `true` է զարգացման build-ներում և `false` արտադրության build-ներում։ Դուք կարող եք փոխել այն `true` որպեսզի միացնեք inspection-ը արտադրության build-ներում։

### errorHandler

- **Տիպ․** `Function`

- **Հիմնական Արժեքը․** `undefined`

- **Օգտագործումը․**

  ``` js
  Vue.config.errorHandler = function (err, vm, info) {
    // բռնել սխալը
    // `info`-ն Vue-ի հատուկ սխալի տեղեկություն է, օրինակ՝ որ lifecycle hook-ում
    // է սխալը հայտնվել։ Միայն հասասնելի է 2.2.0+ տարբերակում
  }
  ```

  Նշանակեք handler չբռնած սխալների համար, կոմպոնենտի render ֆունկցիաների և watcher-ների գործընթացի ժամանակ։ Handler-ը աշխատում է և վերադարձնում է սխալը Vue-ի instance-ի հետ։

  > 2.2.0+, այս hook-ը նաև բռնում է սխալները կոմպոնենտի lifecycle hooks-ի մեջ։ Նաև, երբ որ այս hook-ը `undefined` է, բռնած սխալները log կլինեն որպես `console.error` այլ ոչ թե կկոտրեն ամբողջ ծրագիրը։

  > 2.4.0+, այս hook-ը նաև բռնում է սխալները նետված Vue-ի custom event handler-ների մեջ։

  > 2.6.0+, այս hook-ը նաև բռնում է սխալներ նետված `v-on` DOM listener-ների մեջ։ Ի հավելումն, եթե որևէ մեկը այս hook-երից կամ handler-ներից վերադարձնում են Promise շղթա (օրինակ՝ async ֆունկցիաները), սխալը այդ Promise շղթայի նույնպես կբռնվի։

  > Սխալներին հետևելու ծառայություններ [Sentry](https://sentry.io/for/vue/) և [Bugsnag-ը](https://docs.bugsnag.com/platforms/browsers/vue/) տրամադրում են պաշտոնական ինտեգրացիաներ օգտագործելով այս ընտրանքները։

### warnHandler

> Նոր 2.4.0+

- **Տիպ․** `Function`

- **Հիմնական Արժեքը․** `undefined`

- **Օգտագործումը․**

  ``` js
  Vue.config.warnHandler = function (msg, vm, trace) {
    // `trace`-ը կոմպոնենտի հիերարխիաի հետք է
  }
  ```

  Նշանակեք custom handler-ներ runtime Vue-ի նախազգուշացումների համար։ Նշում՝ այն միայն աշխատում է զարգացման ընթացքում և արտադրության մեջ անտեսվում է։

### ignoredElements

- **Տիպ․** `Array<string | RegExp>`

- **Հիմնական Արժեքը․** `[]`

- **Օգտագործումը․**

  ``` js
  Vue.config.ignoredElements = [
    'my-custom-web-component',
    'another-web-component',
    // Օգտագործեք `RegExp` որպեսզի անտեսեք բոլոր այն էլեմենտներին որոնք սկսվում են «ion-»-ով
    // միայն 2.5+
    /^ion-/
  ]
  ```

  Ստիպեք Vue-ին անտեսել Vue-ից դուրս սահմանված custom Էլեմենտները (օրինակ՝ օգտագործելով Web Components API-ները): Հակառակ դեպքում, դա նախազգուշացում կբերի `Unknown custom element`-ի վերաբերյալ, ենթադրելով, որ մոռացել եք գրանցել գլոբալ կոմպոնենտ կամ սխալ եք գրել կոմպոնենտի անունը:

### keyCodes

- **Տիպ․** `{ [key: string]: number | Array<number> }`

- **Հիմնական Արժեքը․** `{}`

- **Օգտագործումը․**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    // camelCase-ը չի աշխատի
    mediaPlayPause: 179,
    // փոխարենը դուք կարող եք օգտագործել kebab-case զույգ չակերտներով
    "media-play-pause": 179,
    up: [38, 87]
  }
  ```

  ```html
  <input type="text" @keyup.media-play-pause="method">
  ```

  Սահմանեք հատուկ անուններ `v-on`-ի key-ի համար։

### performance

> Նոր 2.2.0+

- **Տիպ․** `boolean`

- **Հիմնական Արժեքը․** `false (2.2.3+ -ից)`

- **Օգտագործումը**:

  Նշելով `true` դուք կմիացնեք կոմպոնենտի init, compile, render և patch կատարման tracing-ը բրաուզերի devtool performance/timeline պատուհանում։ Միայն աշխատում է զարգացման տարբերակում և այն բրաուզերներում որոնք ապահովված են [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API-ով։

### productionTip

> Նոր 2.2.0+

- **Տիպ․** `boolean`

- **Հիմնական Արժեքը․** `true`

- **Օգտագործումը**:

  Վերագրեք սա `false` որպեսզի կանխել արտադրության հուշումը Vue-ի միացման ժամանակ։

## Գլոբալ API

### Vue.extend( options )

- **Արգումենտներ․**
  - `{Object} options`

- **Օգտագործում․**

  Ստեղծեք ենթադաս Vue-ի կոնստրուկտորի հենքից։ Արգումենտը պետք է լինի օբյեկտ պարունակող կոմպոնենտի ընտրանքները։

  Հատուկ դեպքը որ նշված է այստեղ դա `data` տարբերակն է - այն պետք է լինի ֆունկցիա երբ օգտագործվում է `Vue.extend()`-ի հետ.։

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // Ստեղծել կոնստրուկտոր
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Walter',
        lastName: 'White',
        alias: 'Heisenberg'
      }
    }
  })
  // ստեղծել Profile-ի instance և mount անել այն էլեմենտին
  new Profile().$mount('#mount-point')
  ```

  Արդյունքում՝

  ``` html
  <p>Walter White aka Heisenberg</p>
  ```

- **Նաև Նայեք․** [Կոմպոնենտներ](../guide/components.html)

### Vue.nextTick( [callback, context] )

- **Արգումենտներ․**
  - `{Function} [callback]`
  - `{Object} [context]`

- **Օգտագործումը․**

  Հետաձգեք callback-ը որպեսզի այն աշխատի հաջորդ DOM-ի թարմացման ցիկլի ժամանակ։ Օգտագործեք այն անմիջապես հետո երբ որ դուք փոփոխել եք որոշ տվյալներ որպեսզի սպասեք DOM-ի թարմացմանը։

  ``` js
  // փոփոխեք տվյալները
  vm.msg = 'Բարև'
  // DOM-ը թարմեցված չէ դեռ
  Vue.nextTick(function () {
    // DOM-ը թարմացվեց
  })

  // օգտագործումը որպես promise (2.1.0+, նայեք նշումը ներքևում)
  Vue.nextTick()
    .then(function () {
      // DOM-ը թարմացվեց
    })
  ```

  > Նոր 2.1.0+ մեջ: Վերադարձնում է Promise եթե callback տրամադրած չէ և Promise-ը աջակցվում է կատարման միջավայրում։ Խնդրում ենք նկատի ունենալ, որ Vue-ն չունի Promise-ի polyfill, այնպես որ, եթե դուք ստեղծում եք ծրագիր այն բրաուզերների մեջ որոնք չունեն Promise-ներ (նայում են քեզ, IE), դուք ստիպված կլինեք ինքներդ ձեզ տրամադրել polyfill:

- **Նաև Նայեք․** [Async Թարմացման Հերթ](../guide/reactivity.html#Async-Update-Queue)

### Vue.set( target, propertyName/index, value )

- **Արգումենտներ․**
  - `{Object | Array} target`
  - `{string | number} propertyName/index`
  - `{any} value`

- **Վերադարձնում է․** Դրված արժեքը.

- **Օգտագործումը․**

  Ավելացնում է հատկություն ռեակիվ օբյեկտին, համոզվելով որ նոր հատկությունը նույնպես ռեակտիվ է, և այն թարմեցնում է տեսքը։ Այն պետք է օգտագործվի որպեսզի ավելացվեն նոր հատկություններ ռեակտիվ օբյեկտներին, որովհետև Vue-ն չի կարող նկատել հասարակ հատկության ավելացումները (օրինակ՝ `this.myObject.newProperty = 'hi'`):

  <p class="tip">Այս օբյեկտը չի կարող լինել Vue-ի instance, կամ արմատային տվյալների օբյեկտը Vue instance-ի։</p>

- **Նաև Նայեք․** [Ռեակտիվությունը ավելի խորացված](../guide/reactivity.html)

### Vue.delete( target, propertyName/index )

- **Արգումենտներ․**
  - `{Object | Array} target`
  - `{string | number} propertyName/index`

  > Միայն 2.2.0+ և ավելի նոր: Նաև աշխատում է Array + index-ով։

- **Օգտագործումը․**

  Ջնջել օբյեկտի հատկություն։ Եթե օբյեկտը ռեակտիվ է, համոզվեք որ ջնջելը կթամացնի տեսքը։ Սա հիմնականում օգտագործվում է որպեսզի շրջանցել այն սահմանաձակումը որը Vue-ն չի կարող նկատել հատկության ջնջումները, բայց դուք հազվադեպ պետք է օգտագործեք այն։

  <p class="tip">օբյեկտը չի կարող լինել Vue-ի instance, կամ արմատային տվյալների օբյեկտը Vue instance-ի։</p>

- **Նաև Նայեք․** [Ռեակտիվությունը ավելի խորացված](../guide/reactivity.html)

### Vue.directive( id, [definition] )

- **Արգումենտներ․**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Օգտագործում․**

  Գրանցել կամ ստանալ գլոբալ ուղղորդիչ։

  ``` js
  // գրանցել
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // գրանցել (function directive)
  Vue.directive('my-directive', function () {
    // սա կկանչվի որպես `bind` և `update`
  })

  //  ստացող, վերադարձնում է ուղղորդիչի նկարագրությունը եթե այն գրանցված է
  var myDirective = Vue.directive('my-directive')
  ```

- **Նաև Նայեք․** [Custom Ուղղորդիչներ](../guide/custom-directive.html)

### Vue.filter( id, [definition] )

- **Արգումենտներ․**
  - `{string} id`
  - `{Function} [definition]`

- **Օգտագործումը․**

  Գրանցեք կամ ստացեք գլոբալ ֆիլտեր։

  ``` js
  // գրանցում
  Vue.filter('my-filter', function (value) {
    // վերադարձնել ստացված արժեքը
  })

  //  ստացող, վերադարձնում է ֆիլտերը եթե այն գրանցված է
  var myFilter = Vue.filter('my-filter')
  ```

- **Նաև Նայեք․** [Ֆիլտերներ](../guide/filters.html)

### Vue.component( id, [definition] )

- **Արգումենտներ․**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Օգտագործում․**

  Գրանցել կամ ստանալ գլոբալ կոմպոնենտ։ Գրանցումը նաև ավտոմատ կերպով դնում է կոմպոնենտի `name`-ը իրան տված `id`—ով։

  ``` js
  // գրանցել երկարացված կոնստրուկտոր
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // գրանցել ընտրություններ օբյեկտ (ավտոմատ կանչել Vue.extend)
  Vue.component('my-component', { /* ... */ })

  // ստանալ գրանցված կոմպոնենտ (միշտ վերադարձնում է կոնստրուկտորը)
  var MyComponent = Vue.component('my-component')
  ```

- **Նաև Նայեք․** [Կոմպոնենտներ](../guide/components.html)

### Vue.use( plugin )

- **Արգումենտներ․**
  - `{Object | Function} plugin`

- **Օգտագործումը․**

  Տեղադրելով Vue.js plugin: Եթե plugin—ը օբյեկտ է, ապա այն կպարունակի `install` մեթոդ։ Եթե այն ամբողջությամբ ֆունկցիա է, այն կվերաբերվի որպես տեղադրման մեթոդ։ Տեղադրման մեթոդը կկանչվի Vue-ի հետ որպես արգումենտ։

  Այս մեթոդը պետք է կանչվի մինչ դուք կկանչեք `new Vue()`

  Երբ այս մեթոդը կանչվում է նույն plugin—ի մեջ մի քանի անգամ, ապա այս plugin-ը կտեղադրվի միայն մեկ անգամ։

- **Նաև Նայեք․** [Plugin-ներ](../guide/plugins.html)

### Vue.mixin( mixin )

- **Արգումենտներ․**
  - `{Object} mixin`

- **Օգտագործումը․**

  Կիրառեք mixin գլոբալ վիճակով, որը կփոխազդի ամեն Vue instance-ի վրա որը ստեղծվել է հետո։ Սա կարող է օգտագործվել plugin-ի հեղինակների կողմից որպեսզի ներարկել custom behavior-ներ կոմպոնենտների մեջ։ **Խորհուրդ Չի Տրվում Ծրագրի Կոդի Մեջ**։

- **Նաև Նայեք․** [Գլոբալ Mixin-ներ](../guide/mixins.html#Global-Mixin)

### Vue.compile( template )

- **Արգումենտներ․**
  - `{string} template`

- **Օգտագործումը․**

  Compile անել ձևանմուշի string-ները դեպի render ֆունկցիա։ **Հասանելի է միայն full build-ում։**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'բարև'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **Նաև Նայեք․** [Render Ֆունկցիաներ](../guide/render-function.html)

### Vue.observable( object )

> Նոր 2.6.0+ մեջ

- **Արգումենտներ․**
  - `{Object} object`

- **Օգտագործումը․**

  Ստեղծել օբյեկտ ռեակտիվ։ Ներքինով, Vue-ն օգտագործում է սա օբյեկտի վրա որը վերադարձվել է `data` ֆունկցիայի միջոցով։

  Վերադարձված օբյեկտը կարող է օգտագործվել ուղիղ [render ֆունկցիաների](../guide/render-function.html) և [հաշվարկված հատկությունների](../guide/computed.html) մեջ, և այն կկիրառի համապատասխան թարմացումներ երբ մուտացիայի է ենթարկված։ Այն նաև կարող է օգտագործվել որպես մինիմալ, կոմպոնենտից-կոմպոնենտ վիճակի պահեստ հասարակ դեպքերի համար։

  ``` js
  const state = Vue.observable({ count: 0 })

  const Demo = {
    render(h) {
      return h('button', {
        on: { click: () => { state.count++ }}
      }, `count is: ${state.count}`)
    }
  }
  ```

  <p class="tip">Vue 2.x-ի մեջ, `Vue.observable`-ը ուղիղ մուտացիայի է ենթարկում այն օբյեկտը որը փոխանցված է, այն հավասար է նույն վերադարձված օբյեկտին որը [ցուցադրված է այստեղ](../guide/instance.html#Data-and-Methods). Vue 3.x-ի մեջ, ռեակտիվ proxy կվերադարձվի դրա փոխարեն, թողնելով սկզբնական օբյեկտը որպես ոչ ռեակտիվ եթե ուղիղ է մուտացիայի ենթարկված։ Այնուհետև, ապագա համատեղելիության համար, մենք խորհուրդ ենք տալիս միշտ աշխատել այն օբյեկտի հետ որը վերադարձվել է `Vue.observable`-ի միջոցով, ի փոխարեն այն օբյեկտի որը որ փոխանցվել էր իրեն։</p>

- **Նաև Նայեք․** [Ռեակտիվությունը ավելի խորացված](../guide/reactivity.html)

### Vue.version

- **Մանրամասներ**: Տրամադրում է տեղադրված տարբերակը Vue-ի որպես string: Սա հիմնականում օգտակար է plugin-ների և կոմպոնենտների համար, որտեղ դուք կարող եք օգտագործել երբ օգտագործում եք տարբեր տարբերակներ տարբեր պատճառներով։

- **Օգտագործումը**:

  ```js
  var version = Number(Vue.version.split('.')[0])

  if (version === 2) {
    // Vue v2.x.x
  } else if (version === 1) {
    // Vue v1.x.x
  } else {
    // Չհամապատասխանող տարբերակների համար
  }
  ```

## Ընտրանքներ / Տվյալներ

### data

- **Տիպ․** `Object | Function`

- **Սահմանափակում․** Միայն ընդհունում է `Function` երբ օգտագործվում է կոմպոնենտի նկարագրության մեջ։

- **Մանրամասն․**

  Տվյալների օբյեկտը Vue instance-ի համար։ Vue-ն ռեկուրսիվ ձևով կփոփոխի նրա հատկությունները դեպի getter/setter-ներ որպեսզի այն դարձնի «ռեակտիվ»։ **Այս օբյեկտը պետք է լինի պարզ**․ ներքին օբյեկտները ինչպիսիք են բրաուզերի API օբյեկտները կամ prototype հատկությունները նրանք անտեսված են։ Հիմնական կանոնը այն է, որ տվյալները պարզապես պետք է լինեն տվյալներ - խորհուրդ չի տրվում դիտարկել օբյեկտները իրեց սեփական վիճակի behavior-ներով։

  Երբ դիտարկված է, դուք չեք կարող այլևս ավելացնել ռեակտիվ հատկություններ արմատային տվյալների օբյեկտի մեջ։ Որի պատճառով խորհուրդ է տրվում նախօրոք վերագրել բոլոր արմատային աստիճանի ռեակտիվ հատկությունները, նախքան ստեղծելով instance-ը։

  Instance-ը ստեղծելուց հետո, օրիգինալ տվյալների օբյեկտի մեջ կարելի է մուտք գործել `vm.$data`-ի շնորհիվ։ Vue-ի instance-ը proxy է անում բոլոր հատկությունները որոնք գտվնում են տվյալների օբյեկտի վրա, այնուհետև `vm.a` հավասար կլինի `vm.$data.a`-ին։

  Հատկությունները որոնք սկսում են `_` կամ `$`-ով **չեն** proxy-ացվի Vue-ի instance-ի մեջ որովհետև նրանք կարող են կոնֆլիկտ ունենալ Vue-ի ներքին հատկությունների և API մեթոդների հետ։ Դուք պետք է մուտք գործեք նրանց մեջ օգտագործելով `vm.$data._property`։

  Երբ նկարագրում եք **կոմպոնենտ**, `data`-ն պետք է հայտարարված լինի որպես ֆունկցիա որը կվերադարձնի սկզբնական տվյալների օբյեկտը, որովհետև այնտեղ կլինի շատ instance-ներ որոնք ստեղծված են օգտագործելով նույն նկարագրությունը։ Եթե մենք օգտագործենք պարզ օբյեկտ `data`-ի համար, այդ նույն օբյեկտը **կփոխանցվի որպես մեջբերում** բոլոր այն instance-ների մեջ որոնք ստեղծվել են՜ տրամադրելով `data` ֆունկցիա, ամեն անգամ երբ որ նոր instance է ստեղծված մենք կարող ենք կանչել այն որպեսզի վերադարձնի թարմ կրկնօրինակ սկզբնական տվյալններից։

  Եթե պահանջվում է, խորը կրկնօրինակ սկզբնական օբյեկտից դուք կարող եք այն ստանալ փոխանցելով `vm.$data` `JSON.parse(JSON.stringify(...))`-ի միջով։

- **Օրինակ․**

  ``` js
  var data = { a: 1 }

  // ուղիղ instance-ի ստեղծում
  var vm = new Vue({
    data: data
  })
  vm.a // => 1
  vm.$data === data // => true

  // պետք է օգտագործվի ֆունկցիա երբ Vue.extend()-ի մեջ է
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  Նշում եթե դուք ուզում եք օգտագործել սլաքով ֆունկցիա `data` հատկանիշով, `this`-ը չի լինի կոմպոնենտի instance, բայց դուք դեռ կարող եք մուտք գործել instance որպես ֆունկցիայի առաջին արգումենտ։

  ```js
  data: vm => ({ a: vm.myProp })
  ```

- **Նաև Նայեք․** [Ռեակտիվությունը ավելի խորացված](../guide/reactivity.html)

### props

- **Տիպ․** `Array<string> | Object`

- **Մանրամասն․**

  Ատրիբուտների ցանկը/հաշերը որոնք հասանելի են որպեսզի ընդունել տվյալները ծնող կոմպոնենտից։ Այն ունի զանգվածով հիմնված պարզ գրելաձև և այլընտրանքային օբյեկտով հիմնված գրելաձև որը թույլ է տալիս ավելի մանրամասն կոնֆիգուրացիա ինչպիսիք են տիպերի ստուգումները, custom վալիդացիա և հիմնական արժեքներ։

  Օբյեկտով հիմնված գրելաձևում, դուք կարեղ եք օգտագործել հետևյալ ընտրանքները․
    - `type`․ կարող է լինել հետևյալ native կոնստրուկտորներից մեկը․ `String`, `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, `Symbol`, ցանկացած custom կոնստրուկտոր ֆունկցիա կամ զանգված նրանցից։ Կստուգի եթե prop ունի տրված տիպը, և կնետի նախազգուշացում եթե այն չունի։ [Ավելի մանրամասն](../guide/components-props.html#Prop-Types) prop-ի տիպերի վերաբերյալ։
    - `default`: `any`
    Նշում է հիմնական արժեքը prop-ի համար։ Եթե prop-ը փոխանցված չէ, այս արժեքը կօգտագործվի փոխարենը։ Օբյեկտի կամ զանգվածի հիմնական արժեքները պետք է վերադարձվի factory ֆունկցիայից։
    - `required`: `Boolean`
    Հայտարարում է եթե prop-ը պահանջվում է։ Ոչ արտադրողական environment-ում, console-ում նախազգուշացում կնետվի եթե այս արժեքը ճիշտ է և prop-ը փոխանցված չէ։
    - `validator`: `Function`
    Custom վալիդացիայի ֆունկցիա որը ստանում է prop-ի արժեքը որպես իր միակ արգումենտ։ Ոչ արտադրողական environment-ում, console-ում նախազգուշացում կնետվի եթե այս ֆունկցիան վերադարձնում է ոչ ճշմարիտ արժեք (օրինակ վալիդացիան ձախողվում է)։ Դուք կարող եք կարդալ ավելին prop-ի վալիդացիայի վերաբերյալ [այստեղ](../guide/components-props.html#Prop-Validation)։

- **Օրինակներ․**

  ``` js
  // հասարակ գրելաձև
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // օբյեկտի գրելաձև վալիդացիայի հետ
  Vue.component('props-demo-advanced', {
    props: {
      // տիպի ստուգում
      height: Number,
      // տիպի ստուգում և մեկ այլ վալիդացիա
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **Նաև նայեք․** [Prop-ներ](../guide/components-props.html)

### propsData

- **Տիպ․** `{ [key: string]: any }`

- **Սահմանափակումները․** միայն սահմանափակված է instance-ի ստեղծումից `new`-ի շնորհիվ։

- **Մանրամասներ․**

  Փոխանցեք prop-ներ instance-ին իր ստեղծման ժամանակ։ Սա նախատեսված է որպեսզի հեշտացնի unit թեստերը։

- **Օրինակ․**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'hello'
    }
  })
  ```

### computed

- **Տիպը․** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Մանրամասներ․**

  Հաշվարկված հատկությունները որոնք խառնվում են Vue instance-ի հետ։ Բոլոր getter-ները և setter-ները ունեն իրենց `this` մեջբերումը ավտոմատ կերպով կապված Vue instance-ին։

  Նշում որ եթե դուք օգտագործեք սլաքի ֆունկցիաներ հաշվարկված հատկությունների հետ, `this`-ը չի լինի կոմպոնենտի instance-ը, բայց դուք դեռ կարող եք մուտք գործեք դեպի instance որպես ֆունկցիայի առաջին արգումենտ․

  ```js
  computed: {
    aDouble: vm => vm.a * 2
  }
  ```

  Հաշվարկված հատկությունները cache են եղած, և վերահաշվարկվում են ռեակտիվ կախվածության փոփոխություններում։ Նշում որ եթե որևէ կախվածություն դուրս է instance-ի scope-ից (օրինակ ռեակտիվ չէ), հաշվարկված հատկությունը __չի__ թարմացվի։

- **Օրինակ․**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // ստանալ միայն
      aDouble: function () {
        return this.a * 2
      },
      // և ստանալ և տեղադրել
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // => 2
  vm.aPlus = 3
  vm.a       // => 2
  vm.aDouble // => 4
  ```

- **նաև նայեք․** [Հաշվարկված Հատկությունները](../guide/computed.html)

### methods

- **Տիպ․** `{ [key: string]: Function }`

- **Մանրամասներ․**

  Մեթոդներ որոնք պետք է խառնվեն Vue instance-ի հետ։ Դուք կարող եք ուղիղ կերպով մուտք գործել այս մեթոդներ VM instance-ում, կամ օգտագործել նրանց ուղղորդիչների արտահայտություններում։ Բոլոր մեթոդները կունենան իրենց `this` մեջբերումը ավտոմատ կերպով միացված Vue instance-ին։

  <p class="tip">Նշում որ __դուք չպետք է օգտագործեք սլաքով ֆունկցիաներ որպեսզի հայտարարեք մեթոդ__ (օրինակ՝ `plus: () => this.a++`)։ Պատճառը կայանում է որ սլաքով ֆունկցիաները կկապվեն ծնողի մեջբերման հետ, որի պատճառով `this`-ը այլևս չի լինի Vue instance-ը ինչպես որ դուք ակնկալում եք և `this.a`-ը կլինի undefined։</p>

- **Օրինակ․**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **Նաև Նայեք․** [Event-ի Handling-ը](../guide/events.html)

### watch

- **Տիպ․** `{ [key: string]: string | Function | Object | Array}`

- **Մանրամասներ․**

  Օբյեկտ որտեղ key-երը արտահայտություններ են որպեսզի դիտարկվեն և արժեքները համապատասխանող callback-ներն են։ Արժեքը կարող են նաև լինել string որպես մեթոդի անուն, կամ օբյեկտ որը պարունակում հավելյալ ընտրանքներ։ Vue instance կկանչի `$watch()` ամեն օբյեկտի մուտքում ստեղծման ժամանակ։

- **Օրինակ․**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: {
        f: {
          g: 5
        }
      }
    },
    watch: {
      a: function (val, oldVal) {
        console.log('new: %s, old: %s', val, oldVal)
      },
      // string մեթոդի անուն
      b: 'someMethod',
      // այս callback-ը կաշխատի երբ ցանկացած դիտարկված օբյեկտի հատկությունները կփոփոխվեն անկախ նրանց խորությունից
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      },
      // այս անմիջապես կկանչվի դիտարկման սկզբում
      d: {
        handler: 'someMethod',
        immediate: true
      },
      // դուք կարող եք փոխանցել զանգված callback-ների, նրանք մեկ առ մեկ կկանչվեն
      e: [
        'handle1',
        function handle2 (val, oldVal) { /* ... */ },
        {
          handler: function handle3 (val, oldVal) { /* ... */ },
          /* ... */
        }
      ],
      // watch vm.e.f's value: {g: 5}
      'e.f': function (val, oldVal) { /* ... */ }
    }
  })
  vm.a = 2 // => new: 2, old: 1
  ```

  <p class="tip">Նշում որ __դուք չպետք է օգտագործեք սլաքով ֆունկցիաներ որպեսզի հայտարարել watcher__ (օրինակ. `searchQuery: newValue => this.updateAutocomplete(newValue)`)։ Պատճառը կայանում է որ սլաքով ֆունկցիաները կկապվեն ծնողի մեջբերման հետ, այնպես որ `this`-ը չի լինի Vue instance-ը ինչպես որ դուք սպասում եք և `this.updateAutocomplete` կլինի undefined։</p>

- **Նաև Նայեք․** [Instance-ի Մեթոդներ / Տվյալներ - vm.$watch](#vm-watch)

## Ընտրանքներ / DOM

### el

- **Տիպ** `string | Element`

- **Սահմանափակում** միայն հարգված է instance-ի ստեղծման ժամանակ `new`-ի շնորհիվ։

- **Մանրամասներ**

  Տրամադրել Vue instance-ին գոյություն ունեցող DOM էլեմենտ որպեսզի այն տեղադրվի։ Այն կարող է լինել CSS selector string կամ իրական HTMLElement։

  Instance-ի տեղադրումից հետո, հաստատված էլեմենտը կլինի հասանելի որպես `vm.$el`։

  Եթե այս ընտրանքը հասանելի է ստեղծման ժամանակ, instance-ի անիմջապես մուտք կգործի դեպի կոմպիլացիա; հակառակ դեպքում, օգտագործողը պետք է պարտադիր կանչի `vm.$mount()` որպեսզի ձեռքով միացնի կոմպիլացիան։

  <p class="tip">Տրամադրած էլեմենտը ծառայում է որպես տեղադրման կետ։ Տարբերվելով Vue 1.x-ից, տեղադրված էլեմենտը բոլոր դեպքերում կփոխարինվի Vue-ով գեներացված DOM-ով։ Այդ պատճառով խորհուրդ չի տրվում տեղադրելու արմատային instance `<html>` կամ `<body>`-ին։</p>

  <p class="tip">Եթե ոչ `render` ֆունկցիան և ոչ էլ `template` ընտրանքն է ներկա, տեղադրվող DOM էլեմենտի ներքին DOM-ը HTML-ի դուրս կհանվի որպես որպես ձևանմուշ։ Այս դեպքում, Runtime + Compiler կառույցը Vue-ի պետք է օգտագործվի։</p>

- **Նաև Նայեք․**
  - [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)
  - [Runtime + Compiler ընդեմ միայն Runtime-ի](../guide/installation.html#Runtime-Compiler-vs-Runtime-only)

### template

- **Տիպ․** `string`

- **Մանրամասներ․**

  String ձևանմուշը որը պետք է օգտագործվի որպես markup Vue instance-ի համար։ Ձևանմուշը **կփոխարինի** տեղադրված էլեմենտը։ Ցանկացած markup տեղադրված էլեմենտի ներսում կանտեսվի, եթե բովանդակության ընդլայման սլոտները ներկա չեն ձևանմուշում։

  Եթե string-ը սկսում է `#` այն կօգտագործվի որպես querySelector և կօգտագործի ընտրած էլեմենտի innerHTML-ը որպես ձևանմուշի string։ Սա թույլ է տալիս ձեզ օգտագործելու հաճախ հանդիպող `<script type="x-template">` որպեսզի ներառել ձևանմուշներ։

  <p class="tip">Անվտանգության հեռանկարից, դուք պետք է միայն օգտագործեք այն Vue-ի ձևանմուշները որոնք դուք վստահում եք։ Երբեք մի օգտագործեք օգտագործողի կողմից ստեղծված ձևանմուշ։</p>

  <p class="tip">Եթե render ֆունկցիան հասանելի է Vue-ի ընտրանքում, ձևանմուշը կանտեսվի։</p>

- **Նաև նայեք․**
  - [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)
  - [Բովանդակության Ընդլայնում Սլոտների Օգնությամբ](../guide/components.html#Content-Distribution-with-Slots)

### render

  - **Տիպ․** `(createElement: () => VNode) => VNode`

  - **Մանրամասներ․**

    Այլընտրանքային string ձևանմուշների փոխարեն թույլ տալով ձեզ ստանալու JavaScript-ի ամբողջ ծրագրային ուժը։ Render ֆունկցիան ստանում է `createElement` մեթոդը որպես իր առաջին արգումենտ որի միջոցով ստեղծում է `VNode`-երը։

    Եթե կոմպոնենտը ֆունկցիոնալ կոմպոնենտ է, render ֆունկցիան նաև ստանում է հավելյալ արգումենտ `context`, որը տրամադրում է մուտք դեպի կոնտեքստային տվյալներ մինչ ֆունկցիոնալ կոմպոնենտները առանց instance-ի են։

    <p class="tip">`render` ֆունկցիան ունի կարևորություն միուս render ֆունկցիայից որը compile է եղել `template` ընտրանքից կամ տեղադրված էլեմենտի DOM-ի ներքին HTML ձևանմուշից որը նշված է եղել `el` ընտրանքով։</p>

  - **See also:** [Render Ֆունկցիաներ](../guide/render-function.html)

### renderError

> Նոր 2.2.0+-ի մեջ

  - **Տիպ․** `(createElement: () => VNode, error: Error) => VNode`

  - **Մանրամասներ․**

    **Միայն աշխատում է զարգացման ռեժիմում։**

    Տրամադրել այլընտրանքային render-ի ելքագրում երբ հիմնական `render` ֆունկցիան հանդիպում է սխալի։ Սխալը կփոխանցվի `renderError`-ին որպես իր երկրորդ արգումենտ։ Սա հատկապես օգտակար է երբ օգտագործվում է hot-reload-ի հետ։

  - **Օրինակ․**

    ``` js
    new Vue({
      render (h) {
        throw new Error('oops')
      },
      renderError (h, err) {
        return h('pre', { style: { color: 'red' }}, err.stack)
      }
    }).$mount('#app')
    ```

  - **Նաև Նայեք․** [Render Ֆունկցիաներ](../guide/render-function.html)

## Ընտրանքներ / Lifecycle Hook-եր

<p class="tip">Բոլոր lifecycle hook-երը ավտոմատ կերպով կունենան իրենց `this` կոնտեքստ միացված instance-ին, այնպես որ դուք կարող եք մուտք գործել դեպի տվյալներ, հաշվարկված հատկություններ, և մեթոդներ։ Սա նշանակում է որ __դուք չպետք է օգտագործեք սլաքով ֆունկցիաներ որպեսզի հայտարարեք lifecycle մեթոդ__ (օրինակ՝ `created: () => this.fetchTodos()`)։ Պատճառը կայանում է որ սլաքով ֆունկցիաները միացվում են ծնողի կոնտեքստին, այնպես որ `this`-ը չի լինի Vue instance-ը ինչպես դուք եք պատկերացնում և `this.fetchTodos` կլինի undefined։</p>

### beforeCreate

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է սինխրոն ձևով անմիջապես instance-ի գործարկումից հետո, նախքան տվյալների դիտարկումը և event/watcher-ի տեղադրումը։

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### created

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է սինխրոն կերպով instance-ի ստեղծումից հետո։ Այս փուլում, instance ավարտել է վերամշակել ընտրանքները որը նշանակում է որ հետևյալ տեղադրվել է․ տվյալների դիտարկումը, հաշվարկված հատկությունները, մեթոդները, watch/event callback-ները։ Սակայն, տեղադրման փուլը դեռ չի սկսվել, և `$el` հատկությունը դեռ հասանելի չի լինի։

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### beforeMount

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է նախքան տեղադրման սկսումը․ `render` ֆունկցիան կկանչվի առաջին անագամ։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### mounted

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է instance-ի տեղադրումից հետո, որտեղ `el`-ը փոխարինվում է նոր ստեղծված `vm.$el`-ով։ Եթե արմատային instance-ը տեղադրում է փաստաթղթի ներքին էլեմենտին, `vm.$el`-ը նաև կլինի փաստաթղթի ներսում երբ `mounted`-ը կանչվում է։

  Նշում որ `mounted`-ը **չի** երաշխավորում որ նաև բոլոր ժառանգող կոմպոնենտները կտեղադրվեն։ Եթե դուք ցանկանում եք սպասել մինչ տեսադաշտը render է եղել, դուք կարող եք օգտագործել [vm.$nextTick](#vm-nextTick) `mounted`-ի ներսում․

  ``` js
  mounted: function () {
    this.$nextTick(function () {
      // Կոդ որը միայն կաշխատի երբ ամբողջ
      // տեսադաշտը render կլինի
    })
  }
  ```

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### beforeUpdate

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է երբ տվյալները փոփոխվում են, նախքան DOM-ը կապակցված է։ Սա կարող է լավ դիրք լինել որպեսզի մուտք գործել գոյություն ունեցող DOM նախքան թարմացումը, օրինակ․ որպեսզի ջնջել ձեռքով ավելացված event listener-ները։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ, որովհետև միայն սկզբնական render-ն է կատարվում server-side։**

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### updated

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է երբ տվյալների փոփոխությունը պատճառում է որ virtual DOM-ը վերամշակվի և կրկին render լինի։

  Կոմպոնենտի DOM-ը կթարմացվի երբ այս hook-ը կանչվել է, այնպես որ դուք կարող եք կատարել DOM-ին կախված գործողությունները այստեղ։ Սակայն, շատ դեպքերում դուք պետք է խուսափեք վիճակը փոփոխելուց այս hook-ի մեջ։ Որպեսզի արձագանքել վիճակի փոփոխություններին, փոխարենը ավելի հարմար է օգտագործել [հաշվարկված հատկություն](#computed) կամ [watcher](#watch)։

  Նշում որ `updated`-ը **չի** երաշխավորում որ բոլոր ժառանգող կոմպոնենտները նաև կրկին render կլինեն։ Եթե դուք ցանկանում եք սպասել մինչ ամբողջ տեսադաշտի կրկին render լինելը, դուք կարող եք օգտագործել [vm.$nextTick](#vm-nextTick) `updated`-ի ներսում․

  ``` js
  updated: function () {
    this.$nextTick(function () {
      // Կոդը որը միայն կաշխատի ամբողջ
      // տեսադաշտի կրկին render լինելուց հետո
    })
  }
  ```

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### activated

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է երբ keep-alive կոմպոնենտը ակտիվացրած է։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․**
  - [Ներքին Կոմպոնենտներ - keep-alive](#keep-alive)
  - [Դինամիկ Կոմպոնենտներ - keep-alive](../guide/components.html#keep-alive)

### deactivated

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է երբ keep-alive կոմպոնենտը ապակտիվացվում է։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․**
  - [Ներքին Կոմպոնենտներ - keep-alive](#keep-alive)
  - [Դինամիկ Կոմպոնենտներ - keep-alive](../guide/components.html#keep-alive)

### beforeDestroy

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է նախքան Vue instance-ի ոչնչացումը։ Այս փուլում instance-ը դեռ ամբողջովին ֆունկիցոնալ է։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև Նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### destroyed

- **Տիպ․** `Function`

- **Մանրամասներ․**

  Կանչվում է Vue instance-ի ոչնչացումից հետո։ Երբ այս hook-ը կանչվում է, բոլոր ուղղորդիչները Vue instance-ի կլինեն արձակված, բոլոր event listener-ները կլինեն ջնջված, և բոլոր ժառանգող Vue instance-ները կլինեն ոչնչացված։

  **Այս hook-ը չի կանչվում server-side rendering-ի ժամանակ։**

- **Նաև նայեք․** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

### errorCaptured

> Նոր 2.5.0+-ի մեջ

- **Տիպ․** `(err: Error, vm: Component, info: string) => ?boolean`

- **Մանրամասներ․**

  Կանչվում է երբ որևէ սխալ է ժառանգողից հանդիպում։ Այս hook-ը ստանում է երեք արգումենտ․ սխալը, կոմպոնենտի instance-ը որը արձակել է այդ սխալը, և string պարունակող ինֆորմացիա թե որտեղ է սխալը հանդիպել։ Այս hook-ը կարող է վերադարձնել `false` որպեսզի կանգնեցնել սխալը զարգանալուց։

  <p class="tip">Դուք կարող եք փոփոխել կոմպոնենտի վիճակը այս hook-ում։ Սակայն, կարևոր է ունենալ պայմանականներ ձեր ձևանմուշում կան render ֆունկցիա որը կարճ միացում երբ սխալ է հանդիպում; հակառակ դեպքում կոմպոնենտը կլինի անվերջ render ցիկլում։</p>

  **Սխալների Զարգացման Կանոնները**

  - Հիմնականում, բոլոր սխալները կուղարկվեն դեպի գլոբալ `config.errorHandler` եթե այն հայտարարված է, այնպես որ այս սխալները կարող են մեկ տեղում զեկուցվել դեպի վերլուծության ծառայություններ։

  - Եթե բազմաթիվ `errorCaptured` hook-եր գոյություն ունեն կոմպոնենտի ժառանգականության շղթայում կամ ծնողի շղթայում, բոլորը նրանցից կկանչվեն նույն սխալի վրա։

  - Եթե `errorCaptured` hook-ը նետում է սխալ, այս սխալը և օրիգինալը կպահվեն և կուղարկվեն գլոբալ `config.errorHandler`։

  - `errorCaptured` hook-ը կարող է վերադարձնել `false` որպեսզի կանգնացնել սխալը զարգացումից։ Սա պարզապես ասում է որ «այս սխալը կարգավորվել է և պետք է անտեսել այն»։ Այն կկանխի ցանկացած հավելյալ `errorCaptured` hook-եր կամ գլոբալ `config.errorHandler` որը կարձակվի այս սխալի շնորհիվ։

## Ընտրանքներ / Asset-ներ

### directives

- **Տիպ․** `Object`

- **Մանրամասներ․**

  Ուղղորդիչների հաշեր որոնք հասանելի են Vue instance-ին։

- **Նաև նայեք․** [Custom Ուղղորդիճներ](../guide/custom-directive.html)

### filters

- **Տիպ․** `Object`

- **Մանրամասներ․**

  Ֆիլտերների հաշեր որոնք հասանելի են Vue instance-ին։

- **Նաև նայեք․** [`Vue.filter`](#Vue-filter)

### components

- **Տիպ․** `Object`

- **Մանրամասներ․**

  Կոմպոնենտների հաշեր որոնք հասանելի են Vue instance-ին։

- **Նաև նայեք․** [Կոմպոնենտներ](../guide/components.html)

## Ընտրանքներ / Կազմ

### parent

- **Տիպ․** `Vue instance`

- **Մանրամասներ․**

  Նշեք ծնող instance-ը ստեղծվող instance-ին որը պետք է ստեղծվի։ Հաստատում է ծնող-ժառանգող կապ երկուսի միջև։ Ծնողը հասանելի կլինի որպես `this.$parent` ժառանգողի համար, և ժառանգողը կտեղադրվի դեպի ծնողի `$children` զանգվածը։

  <p class="tip">Օգտագործեք `$parent` և `$children` խնայողաբար - և հաճախ ծառայում են որպես այլընտրանք։ Նախընտրեք օգտագործել prop-ները և event-ները ծնող-ժառանգող կապի համար։</p>

### mixins

- **Տիպ․** `Array<Object>`

- **Մանրամասներ․**

  `mixins` ընտրանքը ընդունում է զանգված mixin օբյեկտների։ Այս mixin օբյեկտները կարող են պարունակել instance-ի ընտրանքներ ինչպես պարզ instance օբյեկտներն են, և նրանք կարող են ձուլվել սկզբնական ընտրանքների հետ օգտագործելով նույն ընտրանքների ձուլման տրամաբանությունը `Vue.extend()`-ում։ Օրինակ եթե ձեր mixin-ը պարունակում է created hook-ը և կոմպոնենտը նույնպես ունի այն, երկու ֆունկցիաներն ել կկանչվեն։

  Mixin hook-երը կանչվում են այն հերթականությամբ որոնք որ նրանք տրամադրվել են, և կանչվում է նախքան կոմպոնենտի hook-երը։

- **Օրինակ․**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // => 1
  // => 2
  ```

- **Նաև նայեք․** [Mixin-ներ](../guide/mixins.html)

### extends

- **Տիպ․** `Object | Function`

- **Մանրամասներ․**

  Թույլ է տալիս դեկլարատիվ կերպով ընդլայնել այլ կոմպոնենտ (կարող է լինել հասարակ ընտրանքների օբյեկտ կամ կոնստրուկտոր) առանց օգտագործելու `Vue.extend`-ը։ Սա հիմնականում նախատեսված է որպեսզի հեշտացնել մեկ ֆայլ կոմպոնենտների ընդլայնումը։

  Այն նման է `mixin`-ներին։

- **Օրինակ․**

  ``` js
  var CompA = { ... }

  // ընդլայնենք CompA առանց կանչելու `Vue.extend` երկուսի վրա
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### provide / inject

> Նոր 2.2.0+-ի մեջ

- **Տիպ․**
  - **provide:** `Object | () => Object`
  - **inject:** `Array<string> | { [key: string]: string | Symbol | Object }`

- **Մանրամասներ․**

  Այս ընտրանքների զույգը օգտագործվում է միասին որպեսզի թույլ տալ ծնող կոմպոնենտին ծառայել որպես կախվածության ներարկիչ իր բոլոր ժառանգողների համար, չնայած թե ինչքան խորն է կոմպոնենտների հիերարխիան, քանի դեռ նրանք գտնվում են նույն ծնողի շղթայում։ Եթե դուք ծանող եք React-ին, սա շատ նման է React-ի կոնտեքստի հատկությանը։

  `provide` ընտրանքը պետք է լինի օբյեկտ կամ ֆունկցիա որը վերադարձնում է օբյեկտ։ Այս օբյեկտը պարունակում է հատկություններ որոնք հասանելի են որպեսզի ներարկվեն դեպի իր ժառանգողները։ Դուք կարող եք օգտագործել ES2015 Symbol-ները որպես բանալիներ այս օբյեկտում, բայց միայն միջավայրերում որոնք ներքինով տրամադրում են `Symbol` և `Reflect.ownKeys`։

  `inject` ընտրանքը կարող է լինել հետևյալը․
  - զանգված կամ string-ներ, կամ
  - օբյեկտ որտեղ բանալիները լոկալ կապման անուններն են և արժեքը նշվածներից մեկը․
    - բանալին (string կամ Symbol) որպեսզի փնտրել հասանելի ներարկումները, կամ
    - օբյեկտ որտեղ․
      - `from` հատկությունը բանալին է (string կամ Symbol) որպեսզի փնտրել հասանելի ներարկումները, և
      - `default` հատկությունը օգտագործվում է որպես կանխման արժեք

  > Նշում․ `provide` և `inject` կապումները ռեակտիվ չեն։ Սա դիտավորյալ է։ Սակայն, եթե դուք փոխանցեք դիտարկված օբյեկտ, հատկությունները այդ օբյեկտում կմնան ռեակտիվ։

- **Օրինակ․**

  ``` js
  // ծնող կոմպոնենտը տրամադրում է 'foo'
  var Provider = {
    provide: {
      foo: 'bar'
    },
    // ...
  }

  // ժառանգող կոմպոնենտը ներարկում է 'foo'-ն
  var Child = {
    inject: ['foo'],
    created () {
      console.log(this.foo) // => "bar"
    }
    // ...
  }
  ```

  ES2015 Symbol-ների հետ, ֆունկցիա `provide` և օբյեկտ `inject`․
  ``` js
  const s = Symbol()

  const Provider = {
    provide () {
      return {
        [s]: 'foo'
      }
    }
  }

  const Child = {
    inject: { s },
    // ...
  }
  ```

  > Հաջորդ 2 օրինակները աշխատում են 2.2.1+-ի հետ։ Այդ տարբերակից ներքև, ներարկված արժեքները հաստատվում են `props`-ի և `data`-ի տեղադրումից հետո։

  Օգտագործել ներարկված արժեքը որպես հիմնական արժեք prop-ի համար․
  ```js
  const Child = {
    inject: ['foo'],
    props: {
      bar: {
        default () {
          return this.foo
        }
      }
    }
  }
  ```

  Օգտագործել ներարկված արժեքը որպես տվյալի սկզբնակետ․
  ```js
  const Child = {
    inject: ['foo'],
    data () {
      return {
        bar: this.foo
      }
    }
  }
  ```

  > 2.5.0+-ի մեջ ներարկումները կարող են լինել այլընտրանքային հիմնական արժեքի հետ․

  ``` js
  const Child = {
    inject: {
      foo: { default: 'foo' }
    }
  }
  ```

  Եթե անհրաժեշտ է ներարկել հատկություն մեկ այլ անունով, օգտագործեք `from`-ը որպեսզի նշել սկզբնական հատկությունը․

  ``` js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: 'foo'
      }
    }
  }
  ```

  Նման լինելով prop default-ին, դուք կարող եք օգտագործել factory ֆունկցիա ոչ հասարակ արժեքների համար․

  ``` js
  const Child = {
    inject: {
      foo: {
        from: 'bar',
        default: () => [1, 2, 3]
      }
    }
  }
  ```

## Ընտրանքներ / Այլն

### name

- **Տիպ․** `string`

- **Սահմանափակումներ․** միայն հարգվում է երբ օգտագործվում է որպես կոմպոնենտի ընտրանք։

- **Մանրամասներ․**

  Թույլ տալ կոմպոնենտին որպեսզի ռեկուրսիվ կերպով կանչի ինքն իրեն ձևանմուշի մեջ։ Նշում որ երբ կոմպոնենտը գլոբալ կերպով է գրանցված `Vue.component()`-ով, գլոբալ ID-ն ավտոմատ կերպով տեղադրվում է որպես իր անունը

  Մեկ այլ առավելություն նշելով `name` ընտրանքը դա debugging-ն է։ Անվանված կոմպոնենտները առաջացնում են ավելի օգտակար նախազգուշացման նամակներ։ Նաև, երբ ստուգում եք ծրագիրը [vue-devtools-ում](https://github.com/vuejs/vue-devtools), անանուն կոմպոնենտները կերևան որպես `<AnonymousComponent>`, որը ինֆորմատիվ չե։ Տրամադրելով `name` ընտրանքը, դուք կստանաք ավելի շատ տվյալներ կոմպոնենտի ծառի վերաբերյալ։

### delimiters

- **Տիպ․** `Array<string>`

- **Հիմնական Արժեքը․** `{% raw %}["{{", "}}"]{% endraw %}`

- **Սահմանափակումներ․** Այս ընտրանքը միայն հասանելի է վերջնական կառույցում, բրաուզերի կոմպիլացիայի հետ հանդերձ։

- **Մանրամասներ․**

  Փոփոխել հասարակ տեքստի ինտերպոլացիայի սահմանազատիչները:

- **Օրինակ․**

  ``` js
  new Vue({
    delimiters: ['${', '}']
  })

  // Սահմանազատիչները փոփոխվել են դեպի ES6 ձևանմուշի string-ի ոճի
  ```

### functional

- **Տիպ․** `boolean`

- **Մանրամասներ․**

  Պատճառում է կոմպոնենտին որպեսզի այն լինի առանց վիճակի (ոչ `data`) և առանց instance-ի (ոչ `this` կոնտեքստ)։ Նրանք միայն `render` ֆունկցիա են որը վերադարձնում է վիրտուալ node-երը դարձնելով նրանց ավելի արագ render-ի համար։

- **Նաև նայեք․** [Ֆունկցիոնալ Կոմպոնենտներ](../guide/render-function.html#Functional-Components)

### model

> Նոր 2.2.0-ի մեջ

- **Տիպ․** `{ prop?: string, event?: string }`

- **Մանրամասներ․**

  Թույլ է տալիս custom կոմպոնենտին որպեսզի փոփոխել prop և event-ը որոնք որ օգտագործվում է `v-model`-ի հետ։ Հիմնականում, `v-model`-ը կոմպոնենտում օգտագործում է `value` որպես prop և `input` որպես event, բայց որոշ մուտքագրման տիպեր ինչպիսին են checkbox-երը և radio կոճակները կցանկանան օգտագործել `value` prop մեկ այլ նպատակով։ Օգտագործելով `model` ընտրանքը դուք կարող եք խուսափել կոնֆլիկտներից այս դեպքերում։

- **Օրինակ․**

  ``` js
  Vue.component('my-checkbox', {
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      // սա թույլ է տալիս օգտագործել `value` prop-ը այլ նպատակի համար
      value: String,
      // օգտագործեք `checked` որպես prop որը կփոխարինի `value`-ին
      checked: {
        type: Number,
        default: 0
      }
    },
    // ...
  })
  ```

  ``` html
  <my-checkbox v-model="foo" value="some value"></my-checkbox>
  ```

  Վերևինը հավասար կլինի․

  ``` html
  <my-checkbox
    :checked="foo"
    @change="val => { foo = val }"
    value="some value">
  </my-checkbox>
  ```

### inheritAttrs

> Նոր 2.4.0+-ի մեջ

- **Տիպ․** `boolean`

- **Հիմնական Արժեքը․** `true`

- **Մանրամասներ․**

  Հիմնականում, ծնող scope-ի ատրիբուտի կապուները որոնք չեն ճանաչվել որպես prop-ներ «կձախողվեն» և կկիրառվեն ժառանգող կոմպոնենտի արմատային էլեմենտին որպես հասարակ HTML ատրիբուտներ։ Հեղինակելուց կոմպոնենտը որը փաթաթվում է որևէ էլեմենտի կամ մեկ այլ կոմպոնենտին, սա կարող է միշտ չլինել ցանկացած վիճակը։ Տեղադրելով `inheritAttrs` դեպի `false`, այս հիմնական վիճակը կարող է անջատվել։ Ատրիբուտները հասանելի են `$attrs` instance հատկությունում (նաև նոր է 2.4-ի մեջ) և կարող է հատուկ ձևով կապվել ոչ արմատային էլեմենտին օգտագործելով `v-bind`-ը։

  Նշում․ այս ընտրանքը **չի** ազդում `class` և `style` կապումների վրա։

### comments

> Նոր 2.4.0+-ի մեջ

- **Տիպ․** `boolean`

- **Հիմնական արժեքը․** `false`

- **Սահմանափակումներ․** Այս ընտրանքը միայն հասանելի է ամբողջական կառույցում, բրաուզերի ներքին կոմպիլացիայի հետ հանդերձ։

- **Մանրամասներ․**

  Երբ տեղադրված է դեպի `true`, այն կպահպանի և render կանի HTML comment-ները որոնք գտնվում են ձևանմուշում։ Հիմնական վիճակը նրանց անտեսումն է։

## Instance-ի Հատկություններ

### vm.$data

- **Տիպ․** `Object`

- **Մանրամասներ․**

  Տվյալների օբյեկտը որը Vue instance-ը դիտարկում է։ Vue instance-ը proxy մուտք է գործում դեպի հատկությունները իր տվյալների օբյեկտում։

- **Նաև նայեք․** [Ընտրանքներ / Տվյալներ - data](#data)

### vm.$props

> Նոր 2.2.0+-ի մեջ

- **Տիպ․** `Object`

- **Մանրամասներ․**

  Օբյեկտը որը ներկայացնում է ընթացիկ prop-ները որը կոմպոնենտը ստացել է։ Vue instance proxy մուտք է գործում դեպի հատկություններ իր props օբյեկտում։

### vm.$el

- **Տիպ․** `Element`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Արմատային DOM էլեմենտը որը Vue instance-ը կառավարում է։

### vm.$options

- **Տիպ․** `Object`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Տեղադրելու ընտրանքները որոնք օգտագործվում են ընթացիկ Vue instance-ի համար։ Սա կարող է օգտակար լինել երբ դուք ցանկանում եք ներառել custom հատկություններ ընտրանքներում․

  ``` js
  new Vue({
    customOption: 'foo',
    created: function () {
      console.log(this.$options.customOption) // => 'foo'
    }
  })
  ```

### vm.$parent

- **Տիպ․** `Vue instance`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Ծնողի instance-ը, եթե ընթացիկ instance-ը ունի։

### vm.$root

- **Տիպ․** `Vue instance`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Ընթացիկ կոմպոնենտի ծառի արմատային Vue instance-ը։ Եթե ընթացիկ instance-ը չունի ծնողներ այս արժեքը կլինի հենց ինքը։

### vm.$children

- **Տիպ․** `Array<Vue instance>`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Ուղիղ ժառանգող կոմպոնենտները ընթացիկ instance-ի։ **Նշում որ հերթականության երաշխիք չկա `$children`-ի, և այն ռեակտիվ չէ։** Եթե դուք ցանկանում է օգտագործել `$children`-ը տվյալների կապման համար, հաշվի առեք զանգվածի օգտագործքումը և `v-for`-ը որպեսզի գեներացնել ժառանգող կոմպոնենտներ, և օգտագործել զանգվածը որպես ճշմարտության աղբյուր։

### vm.$slots

- **Տիպ․** `{ [name: string]: ?Array<VNode> }`

- **Միայն կարդալու համար**

- **Ռեակտիվ Է՞** Ոչ

- **Մանրամասներ․**

  Օգտագործվում է որպեզի ծրագրավորեն մուտք գործել դեպի բովանդակություն [բաշխված slot-ներով](../guide/components.html#Content-Distribution-with-Slots)։ Ամեն [անվանված սլոտ](../guide/components.html#Named-Slots) ունի իր համապատասխան հատկությունը (օրինակ. բովանդակությունը `v-slot:foo`-ի հասանելի կլինի `vm.$slots.foo`-ում)։ `default` հատկությունը պարունակում է կամ node-եր որոնք չեն ներառված անվանված սլոտներում կամ բովանդակությունը `v-slot:default`-ի։

  Խնդրում եմ նշեք որ սլոտները ռեակտիվ **չեն**։ Եթե ձեզ անհրաժեշտ է կոմպոնենտ որպեսզի կրկին render անել կախված տվյալների փոփոխություններից որոնք փոխանցվել են սլոտին, մենք խորհուրդ են տալիս օգտագործել մեկ այլ ստրատեգիա որը կախված է ռեակտիվ instance-ի ընտրանքից, ինչպիսին են `props`-ը կամ `data`-ն։

  **Նշում․** `v-slot:foo` չի համապատասխանում v2.6+-ում։ Ավելի հին տարբերակների համար, դուք կարող եք օգտագործել [հնեցված գրելաձևը](../guide/components-slots.html#Deprecated-Syntax)։

  Մուտք գործելով `vm.$slots` շատ օգտակար է երբ գրում եք կոմպոնենտի [render ֆունկցիա](../guide/render-function.html)։

- **Օրինակ․**

  ```html
  <blog-post>
    <template v-slot:header>
      <h1>Իմ մասին</h1>
    </template>

    <p>Այստեղ է էջի բովանդակությունը, որը կներառվի vm.$slots.default-ում, որովհետև այն չի գտնվում անվանված սլոտի ներսում։</p>

    <template v-slot:footer>
      <p>Հեղինակային իրավունք 2016 Evan You</p>
    </template>

    <p>Եթե ես ունենամ որևէ բովանդակություն այստեղ, այն կլինի ներառված vm.$slots.default-ում։</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header),
        createElement('main', body),
        createElement('footer', footer)
      ])
    }
  })
  ```

- **Նաև նայեք․**
  - [`<slot>` Կոմպոնենտ](#slot)
  - [Բովանդակության Բաշխում Սլոտներով](../guide/components.html#Content-Distribution-with-Slots)
  - [Render Ֆունկցիաներ - Սլոտներ](../guide/render-function.html#Slots)

### vm.$scopedSlots

> Նոր 2.1.0+-ի մեջ

- **Տիպ․** `{ [name: string]: props => Array<VNode> | undefined }`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Օգտագործվում է որպեսզի ծրագրավորեն մուտք գործել դեպի [սահմանափակված սլոտներ](../guide/components.html#Scoped-Slots)։ Ամեն սլոտի համար, ներառյալ `default`-ը, օբյեկտը պարունակում է համապատասխան ֆունկցիա որը վերադարձնում է VNode-ները։

  Մուտք գործելով `vm.$scopedSlots` ամենա օգտակարն է երբ գրում եք կոմպոնենտ [render ֆունկցիայի](../guide/render-function.html) հետ։

  **Նշում․** մինչ 2.6.0+, կան երկու կարևոր փոփոխություններ այս հատկության մեջ․

  1. Սահմանափակված սլոտների ֆունկցիաները հիմա երաշխավորված են որ կվերադարձնեն զանգված VNode-երի փոխարեն, բացառությամբ եթե վերադարձված արժեքը սխալ է, որի դեպքում ֆունկցիան կվերադարձնի `undefined`։

  2. Բոլոր `$slots`-ը հիմա հասանելի են `$scopedSlots`-ում որպես ֆունկցիաներ։ Եթե դուք աշխատում եք render ֆունկցիաներով, խորհուրդ է տրվում միշտ մուտք գործել դեպի սլոտներ օգտագործելով `$scopedSlots`-ը, առանց նայելու թե նրանք ունեն scope թե ոչ։ Սա ոչ միայն ապագա վերանվանման փոփոխությունները կհեշտացնի, բայց նաև կհեշտացնի միգրացիան դեպի Vue 3, որտեղ բոլոր սլոտները կլինեն ֆունկցիաներ։

- **Նաև նայեք․**
  - [`<slot>` Կոմպոնենտ](#slot)
  - [Սահմանափակված Սլոտներ](../guide/components.html#Scoped-Slots)
  - [Render Ֆունկցիաներ - Սլոտներ](../guide/render-function.html#Slots)

### vm.$refs

- **Տիպ․** `Object`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  DOM էլեմենտների և կոմպոնենտների instance-ների օբյեկտ, գրանցված [`ref` ատրիբուտով](#ref)։

- **Նաև նայեք․**
  - [Ժառանգող Կոմպոնոնտի Ref-ներ](../guide/components.html#Child-Component-Refs)
  - [Հատուկ Ատրիբուտներ - ref](#ref)

### vm.$isServer

- **Տիպ:** `boolean`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Ցույց է տալիս թե ընթացիկ Vue instance-ը աշխատում է սերվերում թե ոչ։

- **Նաև նայեք․** [Server-Side Rendering](../guide/ssr.html)

### vm.$attrs

> Նոր 2.4.0+-ի մեջ

- **Տիպ․** `{ [key: string]: string }`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Պարունակում է ծնողին կապված ատրիբուտների կապումները (բացառությամբ `class`-ի և `style`-ի) որոնք որ չեն ճանաչվել (և դուրս հանվել) որպես prop-ներ։ Երբ կոմպոնենտը չունի որևէ հայտարարված prop-ներ, սա պարզապես պարունակում է ծնող scope-ի կապումներ (բացառությամբ `class`-ի և `style`-ի), և կարող է փոխանցվել ներքև դեպի ներքին կոմպոնենտ օգտագործելով `v-bind="$attrs"`-ը - օգտակար է երբ ստեղծում եք բարձր կարգի կոմպոնենտներ։

### vm.$listeners

> Նոր 2.4.0+-ի մեջ

- **Տիպ․** `{ [key: string]: Function | Array<Function> }`

- **Միայն կարդալու համար**

- **Մանրամասներ․**

  Պարունակում է ծնող scope-ի `v-on` event listener-ները (առանց `.native` փոփոխիչի)։ Սա կարող է փոխանցվել դեպի ներքին կոմպոնենտ օգտագործելով `v-on="$listeners"` - օգտակար է երբ ստեղծում եք թափանցիկ փաթաթվող կոմպոնենտներ։

## Instance-ի Մեթոդներ / Տվյալներ

### vm.$watch( expOrFn, callback, [options] )

- **Արգումենտներ․**
  - `{string | Function} expOrFn`
  - `{Function | Object} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Վերադարձնում է․** `{Function} unwatch`

- **Օգտագործումը․**

  Դիտարկեք արտահայտությունը կամ հաշվարկված ֆունկցիան Vue instance-ում փոփոխությունների համար։ Այս callback-ը կանչվում է նոր և հին արժեքներով։ Արտահայտությունը միայն ընդունում է կետով սահմանված ճանապարհներ։ Ավելի բարդ արտահայտությունների համար, օգտագործեք ֆունկցիաներ։

<p class="tip">Նշում․ երբ մուտացիայի ենք ենթարկում (քան փոխարինել) Օբյեկտը կամ Զանգվածը, հին արժեքը կլինի նույնը ինչ նոր արժեքը որովհետև նրանք դիմում են նույն Օբյեկտ/Զանգված-ին։ Vue-ն չի պահում նախքան մուտացիայի ենթարկված արժեքի պատճեն։</p>

- **Օրինակ․**

  ``` js
  // բանալիների ճանապարհը
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // Գործողությունները այստեղ
  })

  // ֆունկցիա
  vm.$watch(
    function () {
      // ամեն անգամ արտահայտությունը `this.a + this.b` պարունակում է տարբեր արդյունքներ,
      // գործարկիչը կկանչվի։ Այն նման է հաշվարկված հատկության որը որ մենք դիտարկում ենք
      // առանց հայտարարելու հաշվարկված հատկությունը
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // Գործողությունները այստեղ
    }
  )
  ```

  `vm.$watch` վերադարձնում է չդիտարկված ֆունկցիա որը կանգնեցնում է callback-ի արձակումը․

  ``` js
  var unwatch = vm.$watch('a', cb)
  // հետո, վերացրեք դիտարկիչը
  unwatch()
  ```

- **Ընտրանք․ deep**

  Որպեսզի նկատել խորը տեղադրված արժեքները օբյեկտներում, դուք պետք է փոխանցեք `deep: true` ընտրանքների արգումենտում։ Նշում որ սա անհրաժեշտ չէ եթե ցանկանում է լսել Զանգվածի մուտացիաներին։

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // callback-ը արձակվել է
  ```

- **Ընտրանք․ immediate**

  Փոխանցելով `immediate: true` ընտրանքներում կարձակի callback անմիջապես ընթացիկ արտահայտության արժեքի հետ․

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // `callback`-ը անմիջապես արձակվել է `a` ընթացիկ արժեքով
  ```

  Նշում որ `immediate` ընտրանքով դուք չեք կարող հատկության դիտարկումը կանգնեցնել առաջին callback-ի կանչի ժամանակ։

  ``` js
  // Սա կստեղծի սխալ
  var unwatch = vm.$watch(
    'value',
    function () {
      doSomething()
      unwatch()
    },
    { immediate: true }
  )
  ```

  Եթե դուք դեռ ցանկանում եք կանչել դիտարկումը կանգնացնելու ֆունկցիա callback-ի ներսում, դուք պետք է ստուգեք սկզբում թե այն հասանելի է՞ թե ոչ․

  ``` js
  var unwatch = vm.$watch(
    'value',
    function () {
      doSomething()
      if (unwatch) {
        unwatch()
      }
    },
    { immediate: true }
  )
  ```

### vm.$set( target, propertyName/index, value )

- **Արգումենտներ․**
  - `{Object | Array} target`
  - `{string | number} propertyName/index`
  - `{any} value`

- **Վերադարձնում է․** տեղադրված արժեքը։

- **Օգտագործումը․**

  Սա **փոխանուն է** գլոբալ `Vue.set`-ի։

- **Նաև նայեք․** [Vue.set](#Vue-set)

### vm.$delete( target, propertyName/index )

- **Արգումենտներ․**
  - `{Object | Array} target`
  - `{string | number} propertyName/index`

- **Օգտագործումը․**

  Սա **փոխանուն է** գլոբալ `Vue.delete`-ի։

- **Նաև նայեք․** [Vue.delete](#Vue-delete)

## Instance-ի Մեթոդներ / Event-ներ

### vm.$on( event, callback )

- **Արգումենտներ․**
  - `{string | Array<string>} event` (զանգվածը միայն համապտասխանում է 2.2.0+-ի մեջ)
  - `{Function} callback`

- **Օգտագործումը․**

  Լսեք custom event-ին ընթացիկ vm-ի վրա։ Event-ները կարող են արձակվել `vm.$emit`-ի շնորհիվ։ Callback-ը կստանա բոլոր հավելյալ արգումենտները փոխանցված դեպի այս event-ը արձակող մեթոդներին։

- **Օրինակ․**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'բարև')
  // => "բարև"
  ```

### vm.$once( event, callback )

- **Արգումենտներ:**
  - `{string} event`
  - `{Function} callback`

- **Օգտագործումը․**

  Լսեք custom event-ին, բայց միայն մեկ անգամ։ Այս listener-ը կջնջվի երբ այն կարձակվի առաջին անգամ։

### vm.$off( [event, callback] )

- **Արգումենտներ․**
  - `{string | Array<string>} event` (զանգվածները միայն համապատասխանում է 2.2.2+-ի մեջ)
  - `{Function} [callback]`

- **Օգտագործումը․**

  Ջնջեք custom event listener(ները)։

  - Եթե արգումենտները տրամադրված չեն, բոլոր event listener-ները կջնջվեն;

  - Եթե միայն event-ն է տրամադրված, բոլոր listener-ը կապված այդ event-ին կջնջվեն;

  - Եթե տրամադրված են event և callback, կջնջվեն միայն այն listener-ը որին պատկանում է այդ callback։

### vm.$emit( eventName, [...args] )

- **Արգումենտներ․**
  - `{string} eventName`
  - `[...args]`

  Արձակել event ընթացիկ instance-ում։ Ցանկացած հավելյալ արգումենտները կփոխանցվեն դեպի listener callback ֆունկցիա։

- **Օրինակներ․**

  Օգտագործելով `$emit` միայն event-ի անունի հետ․

  ```js
  Vue.component('welcome-button', {
    template: `
      <button v-on:click="$emit('welcome')">
        Կտտացրեք ինձ ողջունվելու համար
      </button>
    `
  })
  ```
  ```html
  <div id="emit-example-simple">
    <welcome-button v-on:welcome="sayHi"></welcome-button>
  </div>
  ```
  ```js
  new Vue({
    el: '#emit-example-simple',
    methods: {
      sayHi: function () {
        alert('Բարև')
      }
    }
  })
  ```
  {% raw %}
  <div id="emit-example-simple" class="demo">
    <welcome-button v-on:welcome="sayHi"></welcome-button>
  </div>
  <script>
    Vue.component('welcome-button', {
      template: `
        <button v-on:click="$emit('welcome')">
          Կտտացրեք ինձ ողջունվելու համար
        </button>
      `
    })
    new Vue({
      el: '#emit-example-simple',
      methods: {
        sayHi: function () {
          alert('Բարև')
        }
      }
    })
  </script>
  {% endraw %}

  `$emit`-ի օգտագործումը հավելյալ արգումենտներով․

  ```js
  Vue.component('magic-eight-ball', {
    data: function () {
      return {
        possibleAdvice: ['Այո', 'Ոչ', 'Միգուցե']
      }
    },
    methods: {
      giveAdvice: function () {
        var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)
        this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])
      }
    },
    template: `
      <button v-on:click="giveAdvice">
        Կտտացրեք ինձ խորհուրդի համար
      </button>
    `
  })
  ```

  ```html
  <div id="emit-example-argument">
    <magic-eight-ball v-on:give-advice="showAdvice"></magic-eight-ball>
  </div>
  ```

  ```js
  new Vue({
    el: '#emit-example-argument',
    methods: {
      showAdvice: function (advice) {
        alert(advice)
      }
    }
  })
  ```

  {% raw %}
  <div id="emit-example-argument" class="demo">
    <magic-eight-ball v-on:give-advice="showAdvice"></magic-eight-ball>
  </div>
  <script>
    Vue.component('magic-eight-ball', {
      data: function () {
        return {
          possibleAdvice: ['Այո', 'Ոչ', 'Միգուցե']
        }
      },
      methods: {
        giveAdvice: function () {
          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)
          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])
        }
      },
      template: `
        <button v-on:click="giveAdvice">
          Կտտացրեք ինձ խորհուրդի համար
        </button>
      `
    })
    new Vue({
      el: '#emit-example-argument',
      methods: {
        showAdvice: function (advice) {
          alert(advice)
        }
      }
    })
  </script>
  {% endraw %}

## Instance-ի Մեթոդներ / Lifecycle

### vm.$mount( [elementOrSelector] )

- **Արգումենտներ․**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Վերադարձնում է․** `vm` - instance-ը

- **Օգտագործումը․**

  Եթե Vue instance-ը չի ստացել `el` ընտրանքը ստեղծման ժամանակ, այն կլինի «չտեղադրված» վիճակում, չլինելով կապված որևէ DOM էլեմենտի։ `vm.$mount()`-ը կարող է օգտագործվել որպեսզի ձեռքով սկսել տեղադրումը չտեղադրված Vue instance-ի։

  Եթե `elementOrSelector` արգումենտը տրամադրված չէ, ձևանմուշը render կլինի որպես փաստաթղթից դուրս էլեմենտ, և դուք պետք է օգտագործեք ներքին DOM API-ը որպեսզի տեղադրեք այն փաստաթղթի մեջ։

  Մեթոդը վերադարձնում է instance, այնպես որ դուք կարող եք շխթայել այլ instance-ի մեթոդներ նրանից հետո։

- **Օրինակ․**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Բարև</div>'
  })

  // ստեղծել և տեղադրել դեպի #app (կփոխարինի #app-ը)
  new MyComponent().$mount('#app')

  // Վերևում նույնն է ինչ այստեղ․
  new MyComponent({ el: '#app' })

  // կամ, render անել փաստաթղթից դուրս և միացնել այն հետո․
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **Նաև նայեք․**
  - [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)
  - [Server-Side Rendering](../guide/ssr.html)

### vm.$forceUpdate()

- **Օգտագործումը․**

  Ստիպեք Vue instance-ին որպեսզի կրկին render լինի։ Նշում այն չի ազդում բոլոր ժառանգող կոմպոնենտների վրա, միայն instance-ին և ժառանգող կոմպոնենտները-ին որոնք տեղադրվել են սլոտի բովանդակությամբ։

### vm.$nextTick( [callback] )

- **Արգումենտներ․**
  - `{Function} [callback]`

- **Օգտագործումը․**

  Հետաձգել callback-ը որպեսզի աշխատի հաջորդ DOM-ի թարմացման ցիկլում։ Օգտագործեք այն անմիջապես երբ որ դուք փոփոխել եք որոշ տվյալները և սպասում եք DOM-ի թարմացմանը։ Սա նույնն է ինչ գլոբալ `Vue.nextTick`, բացառությամբ որ callback-ի `this` կոնթեքստը ավտոմատ կերպով կկապվի instance-ին որը կանչում է այս մեթոդը։

  > Նոր 2.1.0+-ի մեջ․ վերադարձնում է Promise եթե callback տրամադրված չէ և Promise-ը համապատասխանում է գործարկման միջավայրում։ Խնդրում եմ նշեք որ Vue-ն չունի Promise-ի polyfill, այնպես որ այն բրաուզերները որոնք չունեն Promise-ների ներքին համապատասխանեցում (նայում եմ քեզ, IE), դուք միշտ պետք է տրամադրեք polyfill։

- **Օրինակ․**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // փոփոխեք տվյալները
        this.message = 'changed'
        // DOM-ը դեռ չի թարմացվել
        this.$nextTick(function () {
          // DOM-ը հիմա թարմացվել է
          // `this`-ը կապված է ընթացիկ instance-ին
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **Նաև նայեք․**
  - [Vue.nextTick](#Vue-nextTick)
  - [Ասինխռոն Թարմացման Հերթ](../guide/reactivity.html#Async-Update-Queue)

### vm.$destroy()

- **Օգտագործումը․**

  Ամբողջովին ոչնչացնել vm-ը։ Մաքրել իր բոլոր կապերը գոյություն ունեցող vm-ների հետ, արձակել բոլոր իր ուղղորդիչները, անջատել բոլոր event listener-ները։

  Արձակում է `beforeDestroy` և `destroyed` hook-երը։

  <p class="tip">Հասարակ օգտագործման դեպքերում դուք չպետք է կանչեք այս մեթոդը։ Նախընտրեք կառավարելու lifecycle-ը ժառանգող կոմպոնենտների տվյալներով հենված ձևով օգտագործելով `v-if`-ը և `v-for`-ը։</p>

- **Նաև նայեք:** [Lifecycle-ի Դիագրամ](../guide/instance.html#Lifecycle-Diagram)

## Ուղղորդիչներ

### v-text

- **Ակնկալում է․** `string`

- **Մանրամասներ․**

  Թարմացնում է էլեմենտի `textContent`-ը։ Եթե դուք պետք է թարմացնեք մի մաս `textContent`-ը, դուք պետք է օգտագործեք `{% raw %}{{ Բեղավոր }}{% endraw %}` ինտերպոլացիաներ։

- **Օրինակ․**

  ```html
  <span v-text="msg"></span>
  <!-- նույնն է ինչ -->
  <span>{{msg}}</span>
  ```

- **Նաև նայեք․** [Տվյալների Կապման Գրելաձև - Ինտերպոլացիաներ](../guide/syntax.html#Text)

### v-html

- **Ակնկալում է․** `string`

- **Մանրամասներ․**

  Թարմացնում է էլեմենտի `innerHTML`-ը։ **Նշում որ բովանդակությունները տեղադրված են որպես հասարակ HTML - նրանք compile չեն լինի ինչպես Vue-ի Ձևանմուշները**։ Եթե դուք ցանկանաք մշակել ձևանմուշ օգտագործելով `v-html`, փորձեք կրկին մտածել փոխարենը օգտագործելով կոմպոնենտներ։

  <p class="tip">Դինամիկորեն render եղած հասարակ HTML-ը ձեր կայքում կարող է շատ վտանգավոր լինել որովհետև այն կարող է հանգեցնել [XSS հարձակումների](https://en.wikipedia.org/wiki/Cross-site_scripting)։ Միայն օգտագործեք `v-html`-ը վստահված բովանդակություններում և **երբեք** օգտագործողի կողմից տրամադրված բովանդակությունները։</p>

  <p class="tip">[մեկ ֆայլ կոմպոնենտներում](../guide/single-file-components.html), `scoped` եղած ոճերը չեն կիրառվի `v-html`-ում գտնվող բովանդակությանը, որովհետև այդ HTML չի գործարկվում Vue-ի ձևանմուշի compiler-ը։ Եթե դուք ցանկանում եք թիրախ դնել `v-html`-ի բովանդակությունը սահմանփակված CSS-ով, դուք կարող եք օգտագործել [CSS մոդուլներ](https://vue-loader.vuejs.org/en/features/css-modules.html) կամ հավելյալ, գլոբալ `<style>` էլեմենտ ձեռքով սահմանափակվող ստրատեգիայով ինչպիսին BEM-ն է։</p>

- **Օրինակ․**

  ```html
  <div v-html="html"></div>
  ```

- **Նաև նայեք․** [Տվյալների Կապման Գրելաձև - Ինտերպոլացիաներ](../guide/syntax.html#Raw-HTML)

### v-show

- **Սպասում է․** `any`

- **Օգտագործումը․**

  Փոխարկում է էլեմենտի `display` CSS հատկությունը կախված արտահայտության արժեքի ճշմարտությունից։

  Այս ուղղորդիչը արձակում է անցումները երբ իր պայմանը փոխվում է ։

- **Նաև նայեք․** [Պայմանական Rendering - v-show](../guide/conditional.html#v-show)

### v-if

- **Սպասում է․** `any`

- **Օգտագործումը․**

  Պայմանականորեն render անել էլեմենտը կախված արտահայտության արժեքի ճշմարտությունից։ Էլեմենտը և իր պարունակող ուղղորդիչները / կոմպոնենտները ոչնչացվում և վերակառուցվում են փոխարկման ընթացքում։ Եթե էլեմենտը `<template>` է, իր բովանդակությունը դուրս կհանվի որպես պայմանական բլոկ։

  Այս ուղղորդիչը արձակում է անցումներ և իր պայմանը փոխվում է։

  <p class="tip">Երբ օգտագործվում է v-if-ի հետ, v-for-ը ունի ավելի բարձր կարևորություն քան v-if-ը։ Նայեք <a href="../guide/list.html#v-for-with-v-if">ցանկերի մատուցման ցանկը</a> մանրամասների համար։</p>

- **Նաև նայեք․** [Պայմանական Rendering - v-if](../guide/conditional.html)

### v-else

- **Չի ակնկալում արտահայտություն**

- **Սահմանափակումները․** նախկին հարևան էլեմենտը պետք է ունենա `v-if` կամ `v-else-if`։

- **Օգտագործումը․**

  Նշանակեք «else բլոկը» `v-if` կամ `v-if`/`v-else-if` շխթաների համար։

  ```html
  <div v-if="Math.random() > 0.5">
    Հիմա ինձ տեսնում ես
  </div>
  <div v-else>
    Հիմա ոչ
  </div>
  ```

- **Նաև նայեք․** [Պայմանական Rendering - v-else](../guide/conditional.html#v-else)

### v-else-if

> Նոր 2.1.0+-ի մեջ

- **Սպասում է․** `any`

- **Սահմանափակումները․** նախկին հարևան էլեմենտը պետք է ունենա `v-if` կամ `v-else-if`.

- **Օգտագործումը․**

  Նշանակեք «else if բլոկը» `v-if`-ի համար։ Կարող է շխթայվել։

  ```html
  <div v-if="type === 'A'">
    Ա
  </div>
  <div v-else-if="type === 'B'">
    Բ
  </div>
  <div v-else-if="type === 'C'">
    Գ
  </div>
  <div v-else>
    Ոչ Ա/Բ/Գ
  </div>
  ```

- **Նաև նայեք․** [Պայմանական Rendering - v-else-if](../guide/conditional.html#v-else-if)

### v-for

- **Սպասում է․** `Array | Object | number | string | Iterable (2.6-ից սկսած)`

- **Օգտագործումը․**

  Render անել էլեմենտ կամ ձևանմուշի բլոկ բազմաթիվ անգամ կախված տվյալների աղբյուրից։ Ուղղորդչի արժեքը պետք է օգտագործի `փոխանուն արտահայտության մեջ` որպեսզի տրամադրի փոխանուն ընթացիկ էլեմենտի համար որով ընթանում եք․

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

  Այլ ձև, դուք կարող եք նաև տրամադրել փոխանուն ինդեքսի համար (կամ բանալիի եթե օգտագործվում է Օբյեկտի վրա)․

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, name, index) in object"></div>
  ```

  Հիմնական վարքը `v-for`-ի կփորձի նորոգել էլեմենտները տեղում առանց նրանց շարժելու։ Որպեսզի ստիպել նրան վերադասավորելու էլեմենտները, դուք պետք է տրամադրեք հերթականության հուշում `key` հատուկ ատրիբուտով․

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  2.6+-ի մեջ, `v-for`-ը կարող է նաև աշխատել արժեքների վրա որոնք կիրառում են [Iterable Protocol-ը](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), ներառելով ներքին `Map`-ը և `Set`-ը։ Սակայն, պետք է նշել որ Vue 2.x-ը դեռ չունի ռեակտիվություն `Map` և `Set`-ի արժեքների համար, այն չի կարող ավտոմատ կերպով նկատել փոփոխությունները։

  <p class="tip">Երբ օգտագործվում են v-if-հետ միասին, v-for-ը ունի ավելի բարձր կարևորություն քան v-if։ Նայեք <a href="../guide/list.html#v-for-with-v-if">ցանկի մատուցման ուղեցույցը</a> մանրամասների համար։</p>

  Մանրամասն `v-for`-ի օգտագործումը բացատրված է ներքևում նշված ուղեցույցների հղումներում։

- **Նաև նայեք․**
  - [Ցանկի Rendering](../guide/list.html)
  - [key](../guide/list.html#key)

### v-on

- **Կրճատ․** `@`

- **Սպասում է․** `Function | Inline Statement | Object`

- **Արգումենտներ․** `event`

- **Փոփոխիչներ․**
  - `.stop` - կանչում է `event.stopPropagation()`.
  - `.prevent` - կանչում է `event.preventDefault()`.
  - `.capture` - ավելացնում է event listener capture ռեժիմում։
  - `.self` - միայն արձակում է գործարկիչ եթե event-ը արձակվել է այս էլեմենտից
  - `.{keyCode | keyAlias}` - միայն արձակում է գործարկիչ որոշ բանալիների համար։
  - `.native` - լսել ներքին event-ին կոմպոնենտի արմատային էլեմենտում։
  - `.once` - արձակել գործարկիչը միայն մեկ անգամ։
  - `.left` - (2.2.0+) միայն արձակել գործարկիչը մկնիկի ձախ կոճակի event-ների համար։
  - `.right` - (2.2.0+) միայն արձակել գործարկիչը մկնիկի աջ կոճակի event-ների համար։
  - `.middle` - (2.2.0+) միայն արձակել գործարկիչը մկնիկի մեջտեղի կոճակի event-ների համար։
  - `.passive` - (2.3.0+) միացնում է DOM event `{ passive: true }`-ի հետ։

- **Օգտագործումը․**

  Միացնում է event listener էլեմենտին։ Event-ի տիպը նշանակվում է արգումենտով։ Արտահայտությունը կարող է լինել մեթոդի անուն, inline հայտարարություն, կամ արձակվում է եթե փոփոխիչներ են ներկա։

  Երբ օգտագործվում է հասարակ էլեմենտի վրա, այն լսում է [**ներքին DOM event-ներին**](https://developer.mozilla.org/en-US/docs/Web/Events) միայն։ Երբ օգտագործվում է custom էլեմենտ կոմպոնենտի վրա, այն լսում է **custom event-ներին** արձակված ժառանգող կոմպոնենտներում։

  Երբ լսում եք ներքին DOM event-ներին, այս մեթոդը ստանում է ներքին event որպես միակ արգումենտ։ Եթե օգտագործենք inline հայտարարություն, հայտարարությունը կունենա մուտք դեպի հատուկ `$event` հատկություն։ `v-on:click="handle('ok', $event)"`։

  Սկսած 2.4.0+-ի մեջ, `v-on`-ը նաև համապատասխանում է կապումներ օբյեկտին կազմված զույգ event/listener-ից որոնք առանց արգումենտի են։ Նշում երբ օգտագործում ենք օբյեկտի գրելաձևը, այն չունի փոփոխիչների համապատասխանեցում։

- **Օրինակ․**

  ```html
  <!-- մեթոդի գործարկիչ -->
  <button v-on:click="doThis"></button>

  <!-- դինամիկ event (2.6.0+) -->
  <button v-on:[event]="doThis"></button>

  <!-- inline հայտարարություն -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- կրճատ -->
  <button @click="doThis"></button>

  <!-- կրճատ դինամիկ event (2.6.0+) -->
  <button @[event]="doThis"></button>

  <!-- կանխել տարածումը  -->
  <button @click.stop="doThis"></button>

  <!-- կանխել հիմնականը -->
  <button @click.prevent="doThis"></button>

  <!-- կանխել հիմնականը առանց արտահայտության -->
  <form @submit.prevent></form>

  <!-- սխթայել փոփոխիչները -->
  <button @click.stop.prevent="doThis"></button>

  <!-- կոճակի փոփոխիչները օգտագործելով keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- կոճակի փոփոխիչներ օգտագործելով keyCode -->
  <input @keyup.13="onEnter">

  <!-- կտտացնելու event-ը կարձակվի միայն մեկ անգամ -->
  <button v-on:click.once="doThis"></button>

  <!-- օբյեկտի գրելաձև (2.4.0+) -->
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
  ```

  Сustom event-ների լսումը ժառանգող կոմպոնենտում (գործարկիչը կանչվում է երբ «my-event»-ը արձակված է ժառանգողում)․

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline հայտարարություն -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- ներքին event կոմպոնենտի վրա -->
  <my-component @click.native="onClick"></my-component>
  ```

- **Նաև նայեք․**
  - [Event Handling](../guide/events.html)
  - [Կոմպոնենտներ - Custom Event-ներ](../guide/components.html#Custom-Events)

### v-bind

- **Կարճ․** `:`

- **Սպասում է․** `any (արգումենտով) | Object (առանց արգումենտ)`

- **Արգումենտ․** `attrOrProp (ոչ պարտադիր)`

- **Փոփոխիչներ․**
  - `.prop` - Կապել որպես DOM-ի հատկություն ատրիբուտի փոխարեն ([ի՞նչն է տարբերությունը](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028))։ Եթե tag-ը կոմպոնենտ է ուրեմն `.prop`-ը կտեղադրի կոմպոնենտի `$el`-ի հատկությունը։
  - `.camel` - (2.1.0+) վերափոխում է kebab-case ատրիբուտը դեպի camelCase։
  - `.sync` - (2.3.0+) գրելաձևի շաքար որը ընդլայնվում է դեպի `v-on`-ի գործարկիչ կապված արժեքը թարմացնելու համար։

- **Օգտագործումը․**

  Դինամիկորեն կապել մեկ կամ ավելի ատրիբուտներ, կամ կոմպոնենտի prop արտահայտությանը։

  Երբ օգտագործվում է որպեսզի կապել `class` կամ `style` ատրիբուտը, այն համապատասխանում է հավելյալ արժեքի տիպեր ինչպիսին են Զանգվածը կամ Օբյեկտները։ Նայեք ներքևում ուղեցույցի հղումը ավելի մանրամասների համար։

  Երբ օգտագործվում է prop-ի կապումների համար, prop-ը պետք է ճիշտ հայտարարված լինի ժառանգող կոմպոնենտում։

  Երբ օգտագործվում է առանց արգումենտ, կարող է օգտագործվել որպեսզի կապել օբյեկտ պարունակող ատրիբուտի անուն-արժեք զույգերը։ Նշում որ այս ռեժիմում `class` և `style`-ը չեն համապատասխանում Զանգվածին կամ Օբյեկտներին։

- **Օրինակ․**

  ```html
  <!-- կապել ատրիբուտը -->
  <img v-bind:src="imageSrc">

  <!-- դինամիկ ատրիբուտի անուն (2.6.0+) -->
  <button v-bind:[key]="value"></button>

  <!-- կարճ -->
  <img :src="imageSrc">

  <!-- կարճ դինամիկ ատրիբուտի անուն (2.6.0+) -->
  <button :[key]="value"></button>

  <!-- inline string կոնկատինացումով -->
  <img :src="'/path/to/images/' + fileName">

  <!-- class-ի կապում -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- ոճի կապում -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- ատրիբուտների օբյեկտի կապում -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- DOM ատրիբուտի կապում prop փոփոխիչի հետ -->
  <div v-bind:text-content.prop="text"></div>

  <!-- prop-ի կապում։ «prop»-ը պետք է հայտարարվի my-component-ում։ -->
  <my-component :prop="someThing"></my-component>

  <!-- փոխանցել ծնողի prop-ները որոնք ծանոթ են ժառանգող կոմպոնենտներին -->
  <child-component v-bind="$props"></child-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

  `.camel` փոփոխիչը թույլ է տալիս camelCase դարձնել `v-bind` ատրիբուտի անունը երբ օգտագործում ենք DOM-ի ներքին ձևանմուշներ, օրինակ․ SVG `viewBox` ատրիբուտը․

  ``` html
  <svg :view-box.camel="viewBox"></svg>
  ```

  `.camel`-ը անհրաժեշտ չէ եթե դուք օգտագործում եք string ձևանմուշներ, կամ compile եք անում `vue-loader`/`vueify`-ի հետ։

- **Նաև նայեք․**
  - [Class-ի և Style-ի Կապումները](../guide/class-and-style.html)
  - [Կոմպոնենտներ - Prop-ներ](../guide/components.html#Props)
  - [Կոմպոնենտներ - `.sync` Փոփոխիչ](../guide/components.html#sync-Modifier)

### v-model

- **Ակնկալում է․** կախված է form-ի input-ի կամ կոմպոնենտի ելքագրման արժեքից

- **Սահմանափակված է միայն․**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - կոմպոնենտներ

- **Փոփոխիչներ․**
  - [`.lazy`](../guide/forms.html#lazy) - լսել `change` event-ներին `input`-ի փոխարեն
  - [`.number`](../guide/forms.html#number) - վերածել ճիշտ մուտագրված string-ը դեպի թվեր
  - [`.trim`](../guide/forms.html#trim) - կտրել մուտքագրումը

- **Օգտագործումը․**

  Ստեղծել երկուղի կապում form-ի input էլեմենտի կամ կոմպոնենտի հետ։ Օգտագործման վերաբերյալ մանրամասների համար, նայեք ներքևում գտնվող ուղեցույցի հղումը։

- **Նաև նայեք․**
  - [Form Input-ի Կապումները](../guide/forms.html)
  - [Կոմպոնենտներ - Form Input-ի Կոմպոնենտներ օգտագործելով Custom Event-ներ](../guide/components.html#Form-Input-Components-using-Custom-Events)

### v-slot

- **Կարճ․** `#`

- **Սպասում է․** JavaScript արտահայտություն որը ճիշտ է ֆունկցիայի արգումենտի դիրքում (համապատասխանում է դեստրուկուրային [համապատասխան միջավայրերում](../guide/components-slots.html#Slot-Props-Destructuring))։ Այլընտրանքային - միայն անհրաժեշտ է եթե սպասվող prop-ները փոխանցվում են սլոտին։

- **Արգումենտ․** սլոտի անուն (ոչ պարտադիր, հիմնականում լինում է `default`)

- **Սահմանափակված է մինչ․**
  - `<template>`
  - [կոմպոնենտներ](../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots) (միայնակ հիմանական սլոտի համար prop-ների հետ)

- **Օգտագործումը:**

  Նշանակում է անվանված սլոտները կամ սլոտները որոնք սպասում են prop-ների։

- **Օրինակ․**

  ```html
  <!-- Անվանված սլոտներ -->
  <base-layout>
    <template v-slot:header>
      Header-ի բովանդակություն
    </template>

    Հիմնական սլոտի բովանդակությունը

    <template v-slot:footer>
      Footer-ի բովանդակություն
    </template>
  </base-layout>

  <!-- Անվանված սլոտներ որոնք ստանում են prop-ներ -->
  <infinite-scroll>
    <template v-slot:item="slotProps">
      <div class="item">
        {{ slotProps.item.text }}
      </div>
    </template>
  </infinite-scroll>

  <!-- Հիմնական սլոտ որը ստանում է prop-ներ, ապակառուցման հետ հանդերձ -->
  <mouse-position v-slot="{ x, y }">
    Մկնիկի դիրք․ {{ x }}, {{ y }}
  </mouse-position>
  ```

  Ավելի մանրամասների համար, նայեք ներքևում գտնվող հղումները։

- **Նաև նայեք․**
  - [Կոմպոնենտներ - Սլոտներ](../guide/components-slots.html)
  - [RFC-0001](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)

### v-pre

- **Չի ակնկալում արտահայտություն**

- **Օգտագործումը․**

  Բաց թողնել կոմպիլացիան նշված էլեմենտի և իր ժառանգողների համար։ Դուք կարող եք օգտագործել սա որպեսզի ցուցադրել չմշակված բեղավոր tag-եր։ Բաց թողնելով մեծ թվով node-եր առանց ուղղորդիչների կարող է արագացնել կոմպիլացիան։

- **Օրինակ․**

  ```html
  <span v-pre>{{ սա չի լինի կոմպիլացված }}</span>
   ```

### v-cloak

- **Չի ակնկալում արտահայտություն**

- **Օգտագործումը․**

  Այս ուղղորդիչը կմնա էլեմենտի վրա մինչ կապված Vue instance-ը ավարտում է կոմպիլացիան։ CSS կանոնների հետ համատեղ ինչպիսին են `[v-cloak] { display: none }`, այս ուղղորդիչը կարող է օգտագործվել որպեսզի թակցնել չկոմպիլացված բեղերի կապումներ մինչ Vue instance-ի պատրաստ է։

- **Օրինակ․**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  `<div>`-ը չի լինի տեսանելի մինչ կոմպիլացիան ավատրված է։

### v-once

- **Չի ակնկալում արտահայտություն**

- **Մանրամասներ․**

  Render անել միայն էլեմենտը և կոմպոնենտը։ Կրկնակի render-ների ժամանակ, էլեմենտը/կոմպոնենտը և բոլոր իր ժառանգողները կվերաբերվեն որպես ստատիկ բովանդակություն և բաց կթղնվեն։ Սա կարող է օգտագործվել որպեսզի օպտիմիզացնել թարմացման արագությունը։

  ```html
  <!-- մեկ էլեմենտ -->
  <span v-once>Սա երբեք չի փոխվի․ {{msg}}</span>
  <!-- էլեմենտը ունի ժառանգողներ -->
  <div v-once>
    <h1>մեկնաբանություն</h1>
    <p>{{msg}}</p>
  </div>
  <!-- կոմպոնենտ -->
  <my-component v-once :comment="msg"></my-component>
  <!-- `v-for` ուղղորդիչ -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **Նաև նայեք․**
  - [Տվյալների Կապման Գրելաձև - Ինտերպոլացիաներ](../guide/syntax.html#Text)
  - [Կոմպոնենտներ - Թեթև Ստատիկ Կոմպոնենտներ `v-once`-ի հետ](../guide/components.html#Cheap-Static-Components-with-v-once)

## Հատուկ Ատրիբուտներ

### key

- **Ակնկալում է․** `number | string | boolean (since 2.4.2) | symbol (since 2.5.12)`

  `key` հատուկ ատրիբուտը հիմնականում օգտագործվում է որպես հուշում Vue-ի վիրտուալ DOM-ի ալգորիթմի համար որպեսզի նկատի VNode-երը երբ նոր ցանկի node-երը տարբերվում են հինից։ Առանց key-երի, Vue օգտագործվում է ալգորիթմ որը փոքրացնում է էլէմենտի շարժը և փորձում է նորոգել/վերօգտագործել նույն տիպի էլեմենտները տեղում որքան հնարավոր է։ Key-երի հետ, այն կվերադասավորի էլեմենտը նրանց փոփոխության դեպքում, և էլեմենտը key-երով որոնք այլևս ներկա չեն միշտ կլինեն ջնջված/ոչնչացված։

  Ժառանգողները նույն ընդհանուր ծնողի պետք է ունենան **հատուկ բանալիներ**։ Կրկնվող բանալիները կստեղծեն render-ի սխալներ։

  Ամենա հաճախ օգտագործվող դեպքը դա `v-for`-ի հետ հանդերձ է․

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Սա նաև կարող է օգտագործվել որպեսզի ստիպել փոխարինումը էլեմենտի/կոմպոնենտի վերօգտագործման փոխարեն։ Սա կարող է օգտակար լինել երբ որ դուք ցանկանում եք․

  - Ճիշտ ձևով արձակել կոմպոնենտի lifecycle hook-երը
  - Արձակել անցումներ

  Օրինակի համար․

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  Երբ `text`-ը փոփոխվում է, `<span>` միշտ կլինի փոխարինված վերանորոգվելու փոխարեն, այնպես որ անցումը կարձակվի։

### ref

- **Ակնկալում է․** `string`

  `ref`-ը օգտագործվում է որպեսզի գրանցել դիմելու միջոց դեպի էլեմենտ կամ ժառանգող կոմպոնենտ։ Այս դիմելու միջոցը կգրանցվի ծնող կոմպոնենտի `$refs` օբյեկտի մեջ։ Եթե օգտագործվի հասարակ DOM էլեմենտի վրա, այդ դիմումը կլինի դեպի էլեմենտ; եթե օգտագործվում է ժառանգող կոմպոնենտի վրա, դիմումը կլինի կոմպոնենտի instance․

  ``` html
  <!-- vm.$refs.p կլինի DOM node-ը -->
  <p ref="p">բարև</p>

  <!-- vm.$refs.child կլինի ժառանգող կոմպոնենտի instance-ը -->
  <child-component ref="child"></child-component>
  ```

  Երբ օգտագործվում է էլեմենտների/կոմպոնենտների վրա `v-for`-ի հետ, գրանցված դիմումը կլինի Զանգված պարունակող DOM node-եր կամ կոմպոնենտի instance-ներ։

  Կարևոր նշում ref-ի գրանցման մասին․ որովհետև ref-ները ստեղծվում են որպես render ֆունկցիայի արդյունք, դուք չեք կարող մուտք գործել նրանց մեջ սկզբնական render-ի ժամանակ - որովհետև նրանք դեռ գոյություն չունեն՜ `$refs`-ը նաև ոչ-ռեակտիվ է, այնպես որ դուք չպետք է փորձեք օգտագործել նրանց ձևանմուշներում տվյանլերի կապման համար։

- **Նաև նայեք․** [Ժառանգող Կոմպոնենտների Ref-եր](../guide/components.html#Child-Component-Refs)

### is

- **Սպասում է․** `string | Object (component’s options object)`

  Օգտագործվում է [դինամիկ կոմպոնենտների](../guide/components.html#Dynamic-Components) համար և համարվում է շրջանցում [DOM-ի ներքին ձևանմուշների սահմանափակումների համար](../guide/components.html#DOM-Template-Parsing-Caveats)։

  Օրինակի համար․

  ``` html
  <!-- կոմպոնենտի փոփոխությունները երբ currentView-ը փոխվում է -->
  <component v-bind:is="currentView"></component>

  <!-- անհրաժեշտ է որովհետև `<my-row>`-ը կլինի սխալ ներքուստ -->
  <!-- `<table>` էլեմենտը և կլինի բարձրացված վերև -->
  <table>
    <tr is="my-row"></tr>
  </table>
  ```

  Մանրամասն օգտագործման վերաբերյալ, հետևեք հղումները վերևում նշված մեկնաբանություններում։

- **Նաև նայեք․**
  - [Դինամիկ Կոմպոնենտներ](../guide/components.html#Dynamic-Components)
  - [DOM-ի Ձևանմուշների Գործարկման Պայմանները](../guide/components.html#DOM-Template-Parsing-Caveats)

### slot <sup style="color:#c92222">հնեցված է</sup>

**Նախընտրեք [v-slot](#v-slot) 2.6.0+-ի մեջ։**

- **Սպասում է․** `string`

  Օգտագործվում է տեղադրված բովանդակությունում որը գտնվում է ժառանգող կոմպոնենտի մեջ որպեսզի նշել թե որ անվանված սլոտին է պատկանում բովանդակությունը։

- **Նաև նայեք․** [Անվանված Սլոտներ `slot`-ի հետ](../guide/components.html#Named-Slots-with-slot)

### slot-scope <sup style="color:#c92222">հնեցված է</sup>

**Նախընտրեք [v-slot](#v-slot) 2.6.0+-ի մեջ։**

- **Ակնկալում է․** `ֆունկցիայի արգումենտի արտահայտություն`

- **Օգտագործումը․**

  Օգտագործվում է որպեսզի նշել էլեմենտ կամ կոմպոնենտ որպես սահմանափակված սլոտ։ Ատրիբուտների արժեքը պետք է լինի ճիշտ JavaScript-ի արտահայտություն որը կհայտնվի ֆունկցիայի գրանցման արգումենտի դիրքում։ Սա նշանակում է որ համապատասխան միջավայրերում դուք կարող եք օգտագործել ES2015 արտահայտության մեջ որպեսզի ապակառուցել։ Ծառայում է որպես փոխարինող [`scope`](#scope-replaced)-ի համար 2.5.0+-ի մեջ։

  Այս ատրիբուտը չի համապատասխանում դինամիկ կապումներին։

- **Նաև նայեք․** [Scope-ված Սլոտներ `slot-scope`-ի հետ](../guide/components.html#Scoped-Slots-with-slot-scope)

### scope <sup style="color:#c92222">հնեցված է</sup>

**Փոխարինվել է [slot-scope-ով](#slot-scope) 2.5.0+-ի մեջ։ Նախընտրեք [v-slot-ը](#v-slot) 2.6.0+-ի մեջ։**

Օգտագործվում է որպեսզի նշել `<template>` էլեմենտ որպես սահմանափակված սլոտ։

- **Օգտագործումը․**

  Նույնը ինչ [`slot-scope`](#slot-scope) բացառությամբ որ `scope`-ը կարող է միայն օգտագործվել `<template>` էլեմենտներում։

## Ներքին Կոմպոնենտներ

### component

- **Prop-ներ․**
  - `is` - string | ComponentDefinition | ComponentConstructor
  - `inline-template` - boolean

- **Օգտագործումը:**

  «meta կոմպոնենտ» դինամիկ կոմպոնենտների rendering-ի համար։ Իրական կոմպոնենտը որը պետք է render լինի կողմնորոշվում է `is` prop-ով․

  ```html
  <!-- դինամիկ կոմպոնենտ կառավարվող -->
  <!-- `componentId` հատկության շնորհիվ vm-ում -->
  <component :is="componentId"></component>

  <!-- կարող է նաև render անել գրանցված կոմպոնենտ կամ կոմպոնենտ փոխանցված որպես prop -->
  <component :is="$options.components.child"></component>
  ```

- **Նաև նայեք․** [Դինամիկ Կոմպոնենտներ](../guide/components.html#Dynamic-Components)

### transition

- **Prop-ներ․**
  - `name` - string, Օգտագործվում է որպեսզի ավտոմատ կերպով գեներացնել անցում CSS class անունների։ օրինակ․ `name: 'fade'` ավտոմատ կվերափոխվի դեպի `.fade-enter`, `.fade-enter-active`, և այլն։ Հիմնականում լինում է `"v"`։
  - `appear` - boolean, Որոշում է կիրառել անցումներ սկզբնական render-ին թե ոչ։ Հիմանականում լինում է `false`։
  - `css` - boolean, Որոշում է թե կիրառել CSS անցումների class-ներ թե ոչ։ Հիմնականում `true` է։ Եթե տեղադրված է դեպի `false`, այն միայն կարձակի JavaScript-ի hook-եր գրանցված կոմպոնենտնի event-ներում։
  - `type` - string, Նշանակում է անցման event-ների տիպը որպեսզի այն սպասի որ կողմնորոշվի անցման վերջնակետը։ Հասանելի արժեքները դա `"transition"` և `"animation"`-ն են։ Հիմնականում, այն ավտոմատ կերպով նկատում է տիպը որը ունի ավելի երկար տևողություն։
  - `mode` - string, Կառավարում է ժամանակի հերթականությունը ելքի/մուտքի անցումների։ Հասանելի ռեժիմները դա `"out-in"` և `"in-out"`-ն են; հիմնականում երկուսն ել ակտիվ են։
  - `duration` - number | { `enter`: number, `leave`: number }, Նշում է երկարությունը անցման։ Հիմնականում, Vue-ն սպասում է առաջին `transitionend` կամ `animationend` event-ին արմատային անցման էլեմենտում
  - `enter-class` - string
  - `leave-class` - string
  - `appear-class` - string
  - `enter-to-class` - string
  - `leave-to-class` - string
  - `appear-to-class` - string
  - `enter-active-class` - string
  - `leave-active-class` - string
  - `appear-active-class` - string

- **Events:**
  - `before-enter`
  - `before-leave`
  - `before-appear`
  - `enter`
  - `leave`
  - `appear`
  - `after-enter`
  - `after-leave`
  - `after-appear`
  - `enter-cancelled`
  - `leave-cancelled` (`v-show` only)
  - `appear-cancelled`

- **Usage:**

  `<transition>` ծառայում է որպես անցման էֆֆեկտներ **մեկ** էլեմենտ/կոմպոնենտնի համար։ `<transition>`-ը միայն կիրառում է անցման վարքը ներքին փաթաթված բովանդակությանը; այն չի render անում հավելյալ DOM էլեմենտ, կամ երևում դիտարկված կոմպոնենտի հիերարխիայում։

  ```html
  <!-- մեկ էլեմենտ -->
  <transition>
    <div v-if="ok">փոխարկված բովանդակություն</div>
  </transition>

  <!-- դինամիկ կոմպոնենտ -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- event-ի կանչ -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">փոխարկված բովանդակություն</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // փոխանցված 'el'-ի համար որը ունի DOM էլեմենտ որպես արգումենտ, որևէ մի բան ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **Նաև նայեք․** [Անցումներ․ Մոտւք, Ելք, և Ցանկերը](../guide/transitions.html)

### transition-group

- **Prop-ներ․**
  - `tag` - string, հիմնականում լինում է `span`։
  - `move-class` - վերագրել CSS class-ը որը կիրառվում է անցման շարջի ժամանակ։
  - բացում է նույն prop-ները ինչ `<transition>`-ը բացառությամբ `mode`-ի։

- **Event-ներ․**
  - բացում է նույն event-ները ինչ `<transition>`։

- **Օգտագործումը․**

  `<transition-group>` ծառայում է որպես անցման էֆֆեկտներ **բազմաթիվ** էլեմենտների/կոմպոնենտների համար։ `<transition-group>` render է անում իրական DOM էլեմենտ։ Հիմնականում այն render է անում `<span>`, և դուք կարող եք կառավարել թե ինչ էլեմենտ այն պետք է մատուցի օգտագործելով `tag` ատրիբուտը։

  Նշում որ ամեն ժառանգողը `<transition-group>`-ում պետք է լինի **հատուկ բանալիներով** որպեսզի անիմացիան ճիշտ աշխատի։

  `<transition-group>`-ը համապատասխանում է շարժվող անցումներին CSS-ի transform-ի շնորհիվ։ Երբ ժառանգողի դիրքը էկրանին փոխվում է թարմացումից հետո, այն կկիրառի շարժական CSS class (ավտոմատ կերպով գեներացված `name` ատրիբուտից կամ կառավարված `move-class` ատրիբուտի շնորհիվ)։ Եթե CSS `transform` հատկությունը «անցումային է» երբ շարժական class-ը կիրառված է, էլեմենտը կշարժվի սահուն կերպով դեպի իր նախատեսված դիրքը օգտագործելով [FLIP տեխնիկան](https://aerotwist.com/blog/flip-your-animations/)։

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **Նաև նայեք․** [Անցումներ: Մուտք, Ելք, և Ցանկեր](../guide/transitions.html)

### keep-alive

- **Prop-ներ․**
  - `include` - string կամ RegExp կամ Array։ Միայն կոմպոնենտները համապատասխանող անուններով cache-ում կպահվի։
  - `exclude` - string կամ RegExp կամ Array։ Ցանկացած կոմպոնենտի համապատախսանող անուն չի cache-ում։
  - `max` - number. Առավելագույն թիվը կոմպոնենտների instance-ների որպեսզի պահվի cache-ում։

- **Օգտագործումը․**

  Երբ փաթաթվում է դինամիկ կոմպոնենտի վրա, `<keep-alive>`-ը cache է անում ոչ ակտիվ կոմպոնենտի instance-ներ առանց նրանց ոչնչացնելու։ Նման լինելով `<transition>`-ի, `<keep-alive>`-ը աբստրակտ կոմպոնենտ է․ այն render չի անում DOM էլեմենտ իրենով, և չի երևում կոմպոնենտի ծնողի շխթայում։

  Երբ կոմպոնենտը փոխարկվում է `<keep-alive>`-ում, իր `activated` և `deactivated` lifecycle hook-երը կկանչվեն հերթականությամբ։

  > 2.2.0+-ի ավելի շուտ տարբերակներում, `activated` և `deactivated`-ը կարձակվեն բոլոր ներքին կոմպոնենտների համար `<keep-alive>`-ի ծառի ներքո։

  Հիմնականում օգտագործվում է որպեսզի պահպանել կոմպոնենտի վիճակը կամ խուսափել վերամատուցումից։

  ```html
  <!-- հասարակ -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- բազմաթիվ պայմանական ժառանգողներ -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- `<transition>`-ի հետ համատեղ օգտագործումը -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

  Նշում, `<keep-alive>`-ը նախատեսված է երբ որոշ դեպքերում այն ունի մեկ ուղիղ ժառանգող կոմպոնենտ որը փոխարկվում է։ Այն չի աշխատում եթե դուք ունեք `v-for` ներսում։ Երբ կան բազմաթիվ պայմանական ժառանգողներ, ինչպես վերևում `<keep-alive>` պահանջում է որ միայն մեկ ժառանգող մատուցվի միաժամանակ։

- **`include` և `exclude`**

  > Նոր 2.1.0+-ի մեջ

  `include` և `exclude` prop-ներ թույլ են տալիս կոմպոնենտներին որպեսզի նրանք պայմանականորեն պահպանվեն cache-ում։ Երկու prop-ները կարող են լինել բաժանված ստորակետներով string, RegExp կամ Զանգված․

  ``` html
  <!-- ստորակետով բաժանված string -->
  <keep-alive include="a,b">
    <component :is="view"></component>
  </keep-alive>

  <!-- regex (օգտագործեք `v-bind`) -->
  <keep-alive :include="/a|b/">
    <component :is="view"></component>
  </keep-alive>

  <!-- Զանգված (օգտագործեք `v-bind`) -->
  <keep-alive :include="['a', 'b']">
    <component :is="view"></component>
  </keep-alive>
  ```

  Համապատասխանեցման սկզբում ստուգվում է կոմպոնենտի `name` ընտրանքում, այնուհետև իր լոկալ գրանցման անվան (key-ն ծնողի `components` ընտրանքում) եթե `name` ընտրանքը հասանելի չէ։ Անանուն կոմպոնենտները չեն կարող համապատասնախել։

- **`max`**

  > Նոր 2.5.0+-ի մեջ

  Առավելագույն թիվը կոմպոնենտի instance-ների cache անելու համար։ Հենց հասնում է այս թվին, cache եղած կոմպոնենտի instance-ը որը գրանցվել էր ամենաշուտը կոչնչացվի նախքան նոր instance-ի ստեղծումը։

  ``` html
  <keep-alive :max="10">
    <component :is="view"></component>
  </keep-alive>
  ```

  <p class="tip">`<keep-alive>` չի աշխատում ֆունկցիոնալ կոմպոնենտների հետ որոովհետև նրանց չունեն instance-ներ որպեսզի cache լինեն։</p>

- **Նաև նայեք․** [Դինամիկ Կոմպոնենտներ - keep-alive](../guide/components.html#keep-alive)

### slot

- **Prop-ներ․**
  - `name` - string, Օգտագործվում է անվանված սլոտենրի համար

- **Օգտագործումը․**

  `<slot>`-ը ծառայում է որպես բովանդակության բաշխման ելքագրում կոմպոնենտնի ձևանմուշներում։ `<slot>`-ը իրենով կփոխարինվի։

  Ավելի մանրամասն օգտագործման համար, նայեք ուղեցույցի բաժինը ներքևի հղումներում։

- **Նաև նայեք․** [Բովանդակության Բաշխում Սլոտների Հետ](../guide/components.html#Content-Distribution-with-Slots)

## VNode-ի Interface

- Խնդում ենք դիմել [VNode class-ի հայտարարմանը](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js)։

## Server-Side Rendering

- Խնդրում ենք դիմել [vue-server-renderer գրադարանի փաստաթղթավորումը](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer)։
